
module dram_l2if (
      dram_ucb_ack_vld, dram_ucb_nack_vld, dram_ucb_data, 
   l2if_que_rd_req_vld, l2if_que_wr_req_vld, l2if_que_addr, 
   l2if_que_data, dram_sctag_chunk_id, dram_sctag_data_vld, 
   dram_sctag_rd_req_id, dram_sctag_data, dram_sctag_mecc_err, 
   dram_sctag_pa_err, dram_sctag_secc_err, dram_sctag_ecc, 
   dram_sctag_rd_ack, dram_sctag_wr_ack, l2if_data_mecc0, 
   l2if_data_mecc1, l2if_data_mecc2, l2if_data_mecc3, 
   l2if_data_mecc4, l2if_data_mecc5, l2if_data_mecc6, 
   l2if_data_mecc7, l2if_data_wr_addr, dram_cpu_wr_addr, 
   dram_cpu_wr_en, dram_cpu_wr_data, l2if_wr_req, l2if_rd_req, 
   l2if_rd_addr, l2if_wr_addr, l2if_rd_id, l2if_scrb_data_en, 
   l2if_scrb_data, l2if_scrb_ecc, l2if_err_loc, l2if_err_cnt, 
   l2if_dbg_trig_en, l2if_err_intr, dram_sctag_scb_mecc_err, 
   dram_sctag_scb_secc_err, l2if_err_addr_reg, l2if_err_sts_reg, 
   dram_data_val_other_ch, dp_data_valid_d1, l2if_channel_disabled, 
   err_loc, err_syn, l2if_ucb_trig, l2if_que_selfrsh, 
      clk, rst_l, arst_l, ucb_l2if_selfrsh, que_wr_req,
   sctag_dram_rd_req, sctag_dram_rd_dummy_req, sctag_dram_rd_req_id, 
   sctag_dram_addr, sctag_dram_wr_req, sctag_dram_data_vld, 
   sctag_dram_wr_data, sctag_dram_data_mecc, readqbank0vld0, 
   readqbank0vld1, readqbank0vld2, readqbank0vld3, writeqbank0vld0, 
   writeqbank0vld1, writeqbank0vld2, writeqbank0vld3, readqbank0vld4, 
   readqbank0vld5, readqbank0vld6, readqbank0vld7, writeqbank0vld4, 
   writeqbank0vld5, writeqbank0vld6, writeqbank0vld7, que_scrb_addr, 
   dram_fail_over_mode, que_wr_entry_free, config_reg, 
   que_rank1_present, ucb_dram_rd_req_vld, ucb_dram_wr_req_vld, 
   ucb_dram_addr, ucb_dram_data, que_eight_bank_mode, 
   que_l2if_ack_vld, que_l2if_nack_vld, que_l2if_data, 
   que_dram_clk_toggle, dp_data_valid, que_l2if_send_info, 
   dp_data_in, dp_ecc_in, dram_dram_rx_sync, dram_dram_tx_sync, 
   dram_jbus_rx_sync, dram_jbus_tx_sync, que_addr_bank_low_sel, 
   que_channel_disabled, other_channel_disabled, ch0_err_loc, 
   ch0_err_syn, ch0_dp_data_valid_d1, ch0_dram_data_val_other_ch, 
   ch0_dram_sctag_chunk_id, ch0_dram_sctag_rd_req_id, 
   ch0_dram_sctag_data, ch0_dram_sctag_ecc, ch0_dram_sctag_mecc_err, 
   ch0_dram_sctag_pa_err, ch0_dram_sctag_secc_err
   );

   input 		clk;
input 		rst_l;
input 		arst_l;

input		ucb_l2if_selfrsh;

input        	sctag_dram_rd_req;
input        	sctag_dram_rd_dummy_req;
input [2:0]     sctag_dram_rd_req_id;
input [39:5]    sctag_dram_addr;

input        	sctag_dram_wr_req;
input		sctag_dram_data_vld;
input [63:0] 	sctag_dram_wr_data;
input		sctag_dram_data_mecc;

input          	readqbank0vld0;
input          	readqbank0vld1;
input          	readqbank0vld2;
input          	readqbank0vld3;
input          	writeqbank0vld0;
input          	writeqbank0vld1;
input          	writeqbank0vld2;
input          	writeqbank0vld3;
input          	readqbank0vld4;
input          	readqbank0vld5;
input          	readqbank0vld6;
input          	readqbank0vld7;
input          	writeqbank0vld4;
input          	writeqbank0vld5;
input          	writeqbank0vld6;
input          	writeqbank0vld7;
input          	que_wr_req;

input [32:0]	que_scrb_addr;
input		dram_fail_over_mode;
input [3:0]	que_wr_entry_free;
input [8:0]	config_reg;
input		que_rank1_present;

input           ucb_dram_rd_req_vld;
input           ucb_dram_wr_req_vld;
input [31:0]    ucb_dram_addr;
input [63:0]    ucb_dram_data;

output          dram_ucb_ack_vld;
output          dram_ucb_nack_vld;
output [63:0]   dram_ucb_data;

output          l2if_que_rd_req_vld;
output          l2if_que_wr_req_vld;
output [31:0]   l2if_que_addr;
output [63:0]   l2if_que_data;

input		que_eight_bank_mode;
input          	que_l2if_ack_vld;
input          	que_l2if_nack_vld;
input [63:0]   	que_l2if_data;

input		que_dram_clk_toggle;
input		dp_data_valid;
input [9:0]    	que_l2if_send_info;

input [255:0]	dp_data_in;
input [31:0]	dp_ecc_in;

output [1:0]  	dram_sctag_chunk_id;
output        	dram_sctag_data_vld;
output [2:0]  	dram_sctag_rd_req_id;
output [127:0] 	dram_sctag_data;
output		dram_sctag_mecc_err;
output		dram_sctag_pa_err;
output		dram_sctag_secc_err;
output [27:0] 	dram_sctag_ecc;
output        	dram_sctag_rd_ack;

output        	dram_sctag_wr_ack;

output [3:0]	l2if_data_mecc0;
output [3:0]	l2if_data_mecc1;
output [3:0]	l2if_data_mecc2;
output [3:0]	l2if_data_mecc3;
output [3:0]	l2if_data_mecc4;
output [3:0]	l2if_data_mecc5;
output [3:0]	l2if_data_mecc6;
output [3:0]	l2if_data_mecc7;

output [2:0]	l2if_data_wr_addr;
output [3:0]	dram_cpu_wr_addr;
output [3:0]	dram_cpu_wr_en;
output [63:0]	dram_cpu_wr_data;

output		l2if_wr_req;
output		l2if_rd_req;
output [35:0]	l2if_rd_addr;
output [35:0]	l2if_wr_addr;
output [2:0]	l2if_rd_id;

output		l2if_scrb_data_en;
output [255:0]	l2if_scrb_data;
output [33:0]	l2if_scrb_ecc;
output [35:0]	l2if_err_loc;
output [17:0]	l2if_err_cnt;
output		l2if_dbg_trig_en;

output		l2if_err_intr;

output		dram_sctag_scb_mecc_err;
output		dram_sctag_scb_secc_err;

output [35:0]	l2if_err_addr_reg;
output [22:0]	l2if_err_sts_reg;

input           dram_dram_rx_sync;
input           dram_dram_tx_sync;
input           dram_jbus_rx_sync;
input           dram_jbus_tx_sync;

input		que_addr_bank_low_sel;

input		que_channel_disabled;
input		other_channel_disabled;
output		dram_data_val_other_ch;
output		dp_data_valid_d1;

input [35:0]	ch0_err_loc;
input [15:0]	ch0_err_syn;
input		ch0_dp_data_valid_d1;
input		ch0_dram_data_val_other_ch;
input [1:0]  	ch0_dram_sctag_chunk_id;
input [2:0]  	ch0_dram_sctag_rd_req_id;
input [127:0] 	ch0_dram_sctag_data;
input [27:0] 	ch0_dram_sctag_ecc;
input		ch0_dram_sctag_mecc_err;
input		ch0_dram_sctag_pa_err;
input		ch0_dram_sctag_secc_err;
output		l2if_channel_disabled;
output [35:0]	err_loc;
output [15:0]	err_syn;

output		l2if_ucb_trig;
output		l2if_que_selfrsh;

wire [35:0]	;
wire [15:0]	ch0_err_syn_d1;
wire		l2if_scrb_data_val;
wire		l2if_trig;
wire		l2if_dummy_data_cnt_val;
wire		l2if_ucb_ack_vld_cpu;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [15:0]	;
wire		l2if_scrb_data_val;
wire		l2if_trig;
wire		l2if_dummy_data_cnt_val;
wire		l2if_ucb_ack_vld_cpu;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		l2if_trig;
wire		l2if_dummy_data_cnt_val;
wire		l2if_ucb_ack_vld_cpu;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		l2if_dummy_data_cnt_val;
wire		l2if_ucb_ack_vld_cpu;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		l2if_ucb_ack_vld_cpu;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		l2if_ucb_nack_vld_cpu;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire [31:0]	l2if_ucb_addr_cpu;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [31:0]	;
wire [63:0]	l2if_ucb_que_data_cpu;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [63:0]	;
wire [63:0]	l2if_ucb_data_cpu;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [63:0]	;
wire [63:0]	l2if_ucb_que_data;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [63:0]	;
wire		l2if_addr_bank_low_sel;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire [1:0]	l2if_data_cnt_d1;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [1:0]	;
wire [1:0]	l2if_data_cnt_d2;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [1:0]	;
wire [1:0]	l2if_data_cnt_d3;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [1:0]	;
wire		l2if_secc_err;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		ecc_multi_lo_err; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		; 
wire		ecc_multi_hi_err; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	; 
wire		; 
wire		l2if_mecc_err_partial;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	; 
wire		;
wire		ecc_single_lo_err; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		; 
wire		ecc_single_hi_err; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	; 
wire		; 
wire [127:0]	ecc_cor_lo_data;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	; 
wire [127:0]	;
wire [127:0]	ecc_cor_hi_data;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [127:0]	;

wire [27:0]	l2if_rd_ecc_lo_d1;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;

wire [27:0]	;
wire [27:0]	l2if_l2_ecc_lo;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [27:0]	;
wire [27:0]	l2if_l2_ecc_hi;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [27:0]	;
wire		l2if_wr_ack;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire		l2if_rd_ack;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire		;
wire [3:0]	l2if_b0_wr_val;
wire [3:0]	;
wire [3:0]	;
wire [3:0]	;
wire [3:0]	;
wire [3:0]	l2if_b0_rd_val;
wire [3:0]	l2if_b1_rd_val;
wire [255:0]	l2if_rd_data_p1;
wire [127:0]	l2if_rd_data_d1;
wire [1:0]	l2if_data_offset;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_b1_rd_val;
wire [255:0]	l2if_rd_data_p1;
wire [127:0]	l2if_rd_data_d1;
wire [1:0]	l2if_data_offset;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [255:0]	l2if_rd_data_p1;
wire [127:0]	l2if_rd_data_d1;
wire [1:0]	l2if_data_offset;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [255:0]	;
wire [127:0]	l2if_rd_data_d1;
wire [1:0]	l2if_data_offset;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire [1:0]	l2if_data_offset;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [1:0]	;
wire		l2if_data_first_chunk_in;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_data_mux_sel_en;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_data_first_chunk;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_l2_val;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [5:0]	l2if_wr_b0_data_addr_in;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [5:0]	;
wire [5:0]	l2if_wr_b0_data_addr;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [5:0]	;
wire [31:0]	l2if_rd_ecc_p1;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [31:0]	;
wire [1:0]	l2if_data_cnt_in;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [1:0]	;
wire [1:0]	l2if_data_cnt;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [1:0]	;
wire		l2if_data_cnt_en;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_add_fifo_valid;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [9:0]	l2if_fifo_ent0;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent1;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent2;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent3;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent4;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent5;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent6;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire [9:0]	l2if_fifo_ent7;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire		l2if_data_valid_reset;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_data_valid_d1;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [9:0]	l2if_send_info;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [9:0]	;
wire		l2if_data_cnt_val;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_add_scrb_valid;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [127:0]	ecc_cor_hi_data_d1;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire [127:0]	ecc_cor_lo_data_d1;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire [127:0]	ecc_cor_mux_hi_data;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire [127:0]	ecc_cor_mux_lo_data;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire		l2if_fifo_reset;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [127:0]	l2if_ecc_cor_data;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [127:0]	;
wire [27:0]	l2if_gen_ecc;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [27:0]	;
wire [3:0]	l2if_mecc0_en;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc1_en;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc2_en;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc3_en;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc4_en;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc5_en;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc6_en;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_mecc7_en;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc0_in;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc1_in;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc2_in;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc3_in;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc4_in;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc5_in;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc6_in;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	l2if_data_mecc7_in;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc0;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc1;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc2;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc3;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc4;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc5;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc6;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [3:0]	data_mecc7;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [32:0]	l2if_scrb_addr;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [32:0]	;
wire [31:0]	l2if_rd_ecc_d1;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [31:0]	;
wire [31:0]	l2if_rd_ecc_d2;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [31:0]	;
wire [31:0]	l2if_rd_ecc_d3;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [31:0]	;
wire [31:0]	l2if_ucb_addr;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [31:0]	;
wire [63:0]	l2if_ucb_data;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [63:0]	;
wire		l2if_dram_clk_toggle_d1;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [35:0]	err_addr_reg;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [22:0]	err_sts_reg;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [22:0]	;
wire [39:4]	l2if_rd_addr_p1;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [39:4]	;
wire [2:0]	l2if_rd_id_p1;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [2:0]	;
wire [39:6]	l2if_wr_addr_p1;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [39:6]	;
wire		l2if_scrb_val_d1;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_scrb_val_d2;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_scrb_val_d3;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry0;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry1;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry2;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry3;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry4;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry5;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry6;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire		l2if_wr_entry7;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [3:0]	l2if_wr_entry_free;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire [35:0]	ecc_loc_lo_d1;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	ecc_loc_hi_d1;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_secc_loc;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [15:0]	l2if_secc_cnt;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [15:0]	;
wire [35:0]	ecc_loc_lo;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	ecc_loc_hi;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_rd_addr;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_rd_addr_lo;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_rd_addr_hi;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_wr_addr;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_wr_addr_lo;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [35:0]	l2if_split_wr_addr_hi;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [35:0]	;
wire [8:0]	l2if_config_reg;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [8:0]	;
wire		l2if_offset_inc;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;
wire [3:0]	l2if_wr_val_cnt;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire [3:0]	;
wire		l2if_rd_dummy_req_p1;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;
wire		;

//////////////////////////////////////////////////////////////////
// Flop L2 input requests
//////////////////////////////////////////////////////////////////

//dram_dram_rx_sync (enable for signals comming from dram clk to fast clk)
//dram_dram_tx_sync (enable for signals going from fast clk to dram clk)
//dram_jbus_rx_sync (enable for signals comming from jbus clk to fast clk)
//dram_jbus_tx_sync (enable for signals going from fast clk to jbus clk)

dff_ns #(2) ff_dram_sync_pulses (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;



dff_ns #(2)  (
        .din ({dram_dram_rx_sync, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din ({, dram_dram_tx_sync}),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .q   ({l2if_dram_rx_sync, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .q   ({, l2if_dram_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .clk (clk));

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .clk ());

dff_ns #(2) ff_jbus_sync_pulses (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

dff_ns #(2)  (
        .din ({dram_jbus_rx_sync, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din ({, dram_jbus_tx_sync}),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .q   ({l2if_jbus_rx_sync, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .q   ({, l2if_jbus_tx_sync}),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .clk (clk));

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .clk ());

dff_ns #(2) ff_dram_sync_pulses_d1 (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

dff_ns #(2)  (
        .din ({l2if_dram_rx_sync, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din ({, l2if_jbus_rx_sync}),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .q   ({l2if_dram_rx_sync_d1, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .q   ({, l2if_jbus_rx_sync_d1}),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .clk (clk));

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .clk ());

// Delay the err_syn and err_loc by 1 cycle to match with data val for 2 channel mode
dffrl_ns #(52)   ff_ch0_syn_loc(
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

dffrl_ns #(52)   (
                .din({ch0_err_loc[35:0], ch0_err_syn[15:0]}),
                .q({ch0_err_loc_d1[35:0], ch0_err_syn_d1[15:0]}),
		.rst_l(rst_l),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  (
                .din({[35:0], [15:0]}),
                .q({[35:0], [15:0]}),
		.rst_l(),
                .clk(clk));

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
                .clk());

// This staged signal is needed in 2 channel mode for muxing the data
dff_ns #(2) ff_ch0_dp_data_valid (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

dff_ns #(2)  (
        .din ({ch0_dp_data_valid_d1, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din ({, other_ch_dp_data_valid_d1}),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .q   ({other_ch_dp_data_valid_d1, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .q   ({, other_ch_dp_data_valid_d2}),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  , }),
        .clk (clk));

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  }),
        .clk ());

wire l2if_wr_req_flop_reset = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

wire  = rst_l & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   =  & ~l2if_wr_ack;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~;

dffrle_ns #(1) l2wrreqflop_cpu (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;

dffrle_ns #(1)  (
        .din (sctag_dram_wr_req),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din (),
        .q   (l2if_wr_req_cpu),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .q   (),
	.en  (sctag_dram_wr_req),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
	.en  (),
	.rst_l (l2if_wr_req_flop_reset),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
	.rst_l (),
        .clk (clk));

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk ());

wire l2if_rd_req_flop_reset = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

wire  = rst_l & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   =  & ~l2if_rd_ack;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~;

dffrle_ns #(1) l2rdreqflop_cpu (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;

dffrle_ns #(1)  (
        .din (sctag_dram_rd_req),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din (),
        .q   (l2if_dram_rd_req),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .q   (),
	.en  (sctag_dram_rd_req),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
	.en  (),
	.rst_l (l2if_rd_req_flop_reset),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
	.rst_l (),
        .clk (clk));

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk ());

wire l2if_rd_dummy_req_flop_reset = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

wire  = rst_l & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   =  & ~((l2if_data_cnt == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~(( == 2'h3) & 
			l2if_rd_dummy_req_p1 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   == 2hh) & 
			 & ~l2if_data_valid_d1 & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~ & ~sctag_dram_rd_dummy_req);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~);

dffrle_ns #(1) l2id_rd_dummy_req (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  );

dffrle_ns #(1)  (
        .din    (sctag_dram_rd_dummy_req),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din    (),
        .q      (l2if_rd_dummy_req_p1),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .q      (),
        .en     (sctag_dram_rd_req),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .en     (),
	.rst_l	(l2if_rd_dummy_req_flop_reset),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
	.rst_l	(),
        .clk    (clk));

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk    ());

wire l2if_rd_req_cpu = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

wire  = l2if_dram_rd_req & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   =  & ~l2if_rd_dummy_req_p1;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   & ~;

// Flop rd address input
dffe_ns #(36) l2addr_rdflop0 (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;

dffe_ns #(36)  (
        .din    ({sctag_dram_addr[39:5], 1'b0}),
        .q      (l2if_rd_addr_p1[39:4]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din    ({[39:5], 1bb}),
        .q      ([39:4]),
        .en     (),
        .clk    (clk));

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk    ());

// generating two channel mode bit

dff_ns #(1) flop_other_channel_disabled (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));


dff_ns #(1)  (
        .din (other_channel_disabled),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din (),
        .q   (l2if_other_channel_disabled),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .q   (),
        .clk (clk));

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk ());

wire l2if_two_channel_mode = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));

wire  = l2if_channel_disabled | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   =  | l2if_other_channel_disabled;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   | ;

dff_ns #(1) flop_two_channel_mode (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ;

dff_ns #(1)  (
        .din (l2if_two_channel_mode),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				   (
        .din (),
        .q   (two_channel_mode),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .q   (),
        .clk (clk));

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ),
        .clk ());

// Generate bank, ras, cas and addr error signals for read addr.
/*dram_addr_gen	AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_hi[32]),
			      .addr_parity(l2if_split_rd_addr_hi[34]),
			      .stack_adr(l2if_split_rd_addr_hi[33]),
			      .rank_adr	(l2if_split_rd_addr_hi[35]),
			      .ras_adr	(l2if_split_rd_addr_hi[31:17]),
			      .cas_adr	(l2if_split_rd_addr_hi[16:3]),
			      .bank_adr	(l2if_split_rd_addr_hi[2:0]),
			      // Inputs
			      .addr_in	(l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
			      .rank1_present(rank1_present),
			      .two_channel_mode(two_channel_mode),
			      .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_rd_addr_lo[32]),
			      .addr_parity(l2if_split_rd_addr_lo[34]),
			      .stack_adr(l2if_split_rd_addr_lo[33]),
                              .rank_adr (l2if_split_rd_addr_lo[35]),
                              .ras_adr  (l2if_split_rd_addr_lo[31:17]),
                              .cas_adr  (l2if_split_rd_addr_lo[16:3]),
                              .bank_adr (l2if_split_rd_addr_lo[2:0]),
                              // Inputs
                              .addr_in  (l2if_rd_addr_p1[39:4]),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .two_channel_mode(two_channel_mode),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_rd_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ));





dram_addr_gen	(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_rd_addr_hi[34]), // Templated
				    .addr_err(l2if_split_rd_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_rd_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_rd_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_rd_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_rd_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_rd_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in(l2if_rd_addr_p1[39:4]), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  (
				    				    .addr_parity([34]), 				    .addr_err([32]), 				    .rank_adr([35]), 				    .stack_adr([33]), 				    .bank_adr([2:0]), 				    .ras_adr([31:17]), 				    .cas_adr([16:3]), 				    				    .addr_in([39:4]), 				    .config_reg([8:0]), 				    .rank1_present(), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ), 				    .eight_bank_mode(), // Templated
				    .two_channel_mode(two_channel_mode)); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  ), 				    .two_channel_mode()); // Templated
dram_addr_gen_lo  dram_rd_addr_gen_lo(/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  )); dram_addr_gen_lo  (/*AUTOINST*/
				      // Outputs
				      .addr_parity(l2if_split_rd_addr_lo[34]), // Templated
				  (
				      				      .addr_parity([34]), 				      .addr_err([32]), 				      .rank_adr([35]), 				      .stack_adr([33]), 				      .bank_adr([2:0]), 				      .ras_adr([31:17]), 				      .cas_adr([16:3]), 				      				      .addr_in([39:4]), 				      .config_reg([8:0]), 				      .rank1_present(), // Templated
				      .eight_bank_mode(l2if_eight_bank_mode), // Templated
				      .two_channel_mode(two_channel_mode)); // Templated
assign l2if_split_rd_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_rd_addr_lo[35:0] : 
					l2if_split_rd_addr_hi[35:0];

dffe_ns #(3) l2id_rdflop0 (
        .din    (sctag_dram_rd_req_id[2:0]),
        .q      (l2if_rd_id_p1[2:0]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				      .eight_bank_mode(), // Templated
				      .two_channel_mode(two_channel_mode)); // Templated
assign l2if_split_rd_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_rd_addr_lo[35:0] : 
					l2if_split_rd_addr_hi[35:0];

dffe_ns #(3) l2id_rdflop0 (
        .din    (sctag_dram_rd_req_id[2:0]),
        .q      (l2if_rd_id_p1[2:0]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				      .two_channel_mode()); // Templated
assign l2if_split_rd_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_rd_addr_lo[35:0] : 
					l2if_split_rd_addr_hi[35:0];

dffe_ns #(3) l2id_rdflop0 (
        .din    (sctag_dram_rd_req_id[2:0]),
        .q      (l2if_rd_id_p1[2:0]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr)); assign [35:0] =  ? l2if_split_rd_addr_lo[35:0] : 
					l2if_split_rd_addr_hi[35:0];

dffe_ns #(3) l2id_rdflop0 (
        .din    (sctag_dram_rd_req_id[2:0]),
        .q      (l2if_rd_id_p1[2:0]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr ? [35:0] : 
					[35:0];

dffe_ns #(3)  (
        .din    (sctag_dram_rd_req_id[2:0]),
        .q      (l2if_rd_id_p1[2:0]),
        .en     (sctag_dram_rd_req),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ([2:0]),
        .q      ([2:0]),
        .en     (),
        .clk    (clk));

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// Flop wr address input
dffe_ns #(34) l2addr_wrflop0 (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(34)  (
        .din    (sctag_dram_addr[39:6]),
        .q      (l2if_wr_addr_p1[39:6]),
        .en     (sctag_dram_wr_req),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ([39:6]),
        .q      ([39:6]),
        .en     (),
        .clk    (clk));

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// Generate bank, ras, cas and addr error signals for wr addr.
/*dram_addr_gen AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_hi[32]),
			      .addr_parity(l2if_split_wr_addr_hi[34]),
			      .stack_adr(l2if_split_wr_addr_hi[33]),
                              .rank_adr (l2if_split_wr_addr_hi[35]),
                              .ras_adr  (l2if_split_wr_addr_hi[31:17]),
                              .cas_adr  (l2if_split_wr_addr_hi[16:3]),
                              .bank_adr (l2if_split_wr_addr_hi[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .rank1_present(rank1_present),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .config_reg(l2if_config_reg[8:0])); */

/*dram_addr_gen_lo AUTO_TEMPLATE( .addr_err(l2if_split_wr_addr_lo[32]),
			      .addr_parity(l2if_split_wr_addr_lo[34]),
			      .stack_adr(l2if_split_wr_addr_lo[33]),
                              .rank_adr (l2if_split_wr_addr_lo[35]),
                              .ras_adr  (l2if_split_wr_addr_lo[31:17]),
                              .cas_adr  (l2if_split_wr_addr_lo[16:3]),
                              .bank_adr (l2if_split_wr_addr_lo[2:0]),
                              // Inputs
                              .addr_in  ({l2if_wr_addr_p1[39:6], 2'h0}),
			      .eight_bank_mode(l2if_eight_bank_mode),
                              .rank1_present(rank1_present),
                              .config_reg(l2if_config_reg[8:0])); */

dram_addr_gen	dram_wr_addr_gen_hi(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));





dram_addr_gen	(/*AUTOINST*/
				    // Outputs
				    .addr_parity(l2if_split_wr_addr_hi[34]), // Templated
				    .addr_err(l2if_split_wr_addr_hi[32]), // Templated
				    .rank_adr(l2if_split_wr_addr_hi[35]), // Templated
				    .stack_adr(l2if_split_wr_addr_hi[33]), // Templated
				    .bank_adr(l2if_split_wr_addr_hi[2:0]), // Templated
				    .ras_adr(l2if_split_wr_addr_hi[31:17]), // Templated
				    .cas_adr(l2if_split_wr_addr_hi[16:3]), // Templated
				    // Inputs
				    .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				    .config_reg(l2if_config_reg[8:0]), // Templated
				    .rank1_present(rank1_present), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
				    				    .addr_parity([34]), 				    .addr_err([32]), 				    .rank_adr([35]), 				    .stack_adr([33]), 				    .bank_adr([2:0]), 				    .ras_adr([31:17]), 				    .cas_adr([16:3]), 				    				    .addr_in({[39:6], 2hh}), 				    .config_reg([8:0]), 				    .rank1_present(), // Templated
				    .eight_bank_mode(l2if_eight_bank_mode), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				    .eight_bank_mode(), // Templated
				    .two_channel_mode(two_channel_mode));

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				    .two_channel_mode());

dram_addr_gen_lo   dram_wr_addr_gen_lo(/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dram_addr_gen_lo   (/*AUTOINST*/
				       // Outputs
				       .addr_parity(l2if_split_wr_addr_lo[34]), // Templated
				       .addr_err(l2if_split_wr_addr_lo[32]), // Templated
				       .rank_adr(l2if_split_wr_addr_lo[35]), // Templated
				       .stack_adr(l2if_split_wr_addr_lo[33]), // Templated
				       .bank_adr(l2if_split_wr_addr_lo[2:0]), // Templated
				       .ras_adr(l2if_split_wr_addr_lo[31:17]), // Templated
				       .cas_adr(l2if_split_wr_addr_lo[16:3]), // Templated
				       // Inputs
				       .addr_in({l2if_wr_addr_p1[39:6], 2'h0}), // Templated
				       .config_reg(l2if_config_reg[8:0]), // Templated
				       .rank1_present(rank1_present), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
				       				       .addr_parity([34]), 				       .addr_err([32]), 				       .rank_adr([35]), 				       .stack_adr([33]), 				       .bank_adr([2:0]), 				       .ras_adr([31:17]), 				       .cas_adr([16:3]), 				       				       .addr_in({[39:6], 2hh}), 				       .config_reg([8:0]), 				       .rank1_present(), // Templated
				       .eight_bank_mode(l2if_eight_bank_mode), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				       .eight_bank_mode(), // Templated
				       .two_channel_mode(two_channel_mode));

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr), 				       .two_channel_mode());

assign l2if_split_wr_addr[35:0] = l2if_addr_bank_low_sel ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

assign [35:0] =  ? l2if_split_wr_addr_lo[35:0] : 
					l2if_split_wr_addr_hi[35:0];

// Flop wr address out of range bit
dffrl_ns #(1) l2addr_wr_en_d1 (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr ? [35:0] : 
					[35:0];

dffrl_ns #(1)  (
        .din    (sctag_dram_wr_req),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    (),
        .q      (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .q      (),
        .rst_l  (rst_l),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .rst_l  (),
        .clk    (clk));

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

wire l2if_wr_addr_err_in = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

wire  = l2if_split_wr_addr[32];

dffrle_ns #(1) l2addr_wr_pa_err (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr = [32];

dffrle_ns #(1)  (
        .din    (l2if_wr_addr_err_in),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    (),
        .q      (l2if_wr_addr_err),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .q      (),
        .en     (l2if_wr_en0_d1),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .en     (),
        .rst_l  (rst_l),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .rst_l  (),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

/////////////////////////////////////////////////
// SIGNALS FROM CPU CLK TO DRAM CLK
/////////////////////////////////////////////////

// write and read req valids
dffe_ns #(2) l2wrreqflop_dram (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));


dffe_ns #(2)  (
        .din    ({l2if_wr_ack, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ({, l2if_rd_req_cpu}),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, }),
        .q      ({l2if_wr_req,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr}),
        .q      ({,l2if_rd_req}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr,}),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr}),
	.en	(),
        .clk    (clk));

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// Error status register 
dffe_ns #(23)   ff_err_sts_reg(
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(23)   (
        .din	(err_sts_reg[22:0]),
        .q	(l2if_err_sts_reg[22:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din	([22:0]),
        .q	([22:0]),
	.en	(),
        .clk	(clk));

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk	());

// Error address register
dffe_ns #(36)   err_addr(
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(36)   (
        .din	(err_addr_reg[35:0]),
        .q	(l2if_err_addr_reg[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din	([35:0]),
        .q	([35:0]),
	.en	(),
        .clk	(clk));

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk	());

// scrb data for dram clk domain
dffe_ns #(256) scrb_data(
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(256) (
        .din	({ecc_cor_hi_data_d1[127:0], ecc_cor_lo_data_d1[127:0]}),
        .q	(l2if_scrb_data[255:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din	({[127:0], [127:0]}),
        .q	([255:0]),
	.en	(),
        .clk	(clk));

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk	());

dffe_ns #(34) scrb_ecc(
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(34) (
        .din	({ecc_multi_hi_err_d1, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din	({, ecc_multi_lo_err_d1, l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, , l2if_rd_ecc_d3[31:16], 
			l2if_rd_ecc_d3[15:0]}),
        .q	(l2if_scrb_ecc[33:0]),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, [31:16], 
			[15:0]}),
        .q	([33:0]),
	.en	(),
        .clk	(clk));

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk	());

// scrub valid signal for dram side
dffe_ns #(2) scrb_val(
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(2) (
        .din	({l2if_dbg_trig, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din	({, l2if_scrb_val_d3}),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, }),
        .q	({l2if_dbg_trig_en, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr}),
        .q	({, l2if_scrb_data_en}),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, }),
	.en	(l2if_dram_tx_sync),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr}),
	.en	(),
        .clk	(clk));

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk	());

// rd address input
dffe_ns #(36) rd_addr (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(36)  (
        .din    (l2if_split_rd_addr[35:0]),
        .q      (l2if_rd_addr[35:0]),
	.en	(l2if_dram_tx_sync),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ([35:0]),
        .q      ([35:0]),
	.en	(),
        .clk    (clk));

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// rd req id
dffe_ns #(3) rd_id (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(3)  (
        .din    (l2if_rd_id_p1[2:0]),
        .q      (l2if_rd_id[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ([2:0]),
        .q      ([2:0]),
        .en     (),
        .clk    (clk));

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// wr address input
dffe_ns #(36) wr_addr (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(36)  (
        .din    (l2if_split_wr_addr[35:0]),
        .q      (l2if_wr_addr[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr (
        .din    ([35:0]),
        .q      ([35:0]),
        .en     (),
        .clk    (clk));

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// data write address into mem
dffe_ns #(3) ff_wr_addr(
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(3) (
        .din    (l2if_wr_b0_data_addr[5:3]),
        .q    	(l2if_data_wr_addr[2:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ([5:3]),
        .q    	([2:0]),
        .en     (),
        .clk    (clk));

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// l2 poison on mecc err bits
dffe_ns #(16) ff_l2_poison0_3(
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(16) (
        .din    ({data_mecc0[3:0], data_mecc1[3:0], data_mecc2[3:0], data_mecc3[3:0]}),
        .q    	({l2if_data_mecc0[3:0], l2if_data_mecc1[3:0], l2if_data_mecc2[3:0], 
				l2if_data_mecc3[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ({[3:0], [3:0], [3:0], [3:0]}),
        .q    	({[3:0], [3:0], [3:0], 
				[3:0]}),
        .en     (),
        .clk    (clk));

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

dffe_ns #(16) ff_l2_poison4_7(
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(16) (
        .din    ({data_mecc4[3:0], data_mecc5[3:0], data_mecc6[3:0], data_mecc7[3:0]}),
        .q    	({l2if_data_mecc4[3:0], l2if_data_mecc5[3:0], l2if_data_mecc6[3:0], 
				l2if_data_mecc7[3:0]}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ({[3:0], [3:0], [3:0], [3:0]}),
        .q    	({[3:0], [3:0], [3:0], 
				[3:0]}),
        .en     (),
        .clk    (clk));

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// ecc loc reg
dffe_ns #(36) ff_ecc_loc_reg(
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(36) (
        .din    (l2if_secc_loc[35:0]),
        .q    	(l2if_err_loc[35:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ([35:0]),
        .q    	([35:0]),
        .en     (),
        .clk    (clk));

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// err counter reg
dffe_ns #(18) ff_err_cnt_reg(
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(18) (
        .din    ({l2if_secc_int_enabled, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ({, l2if_secc_vld, l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, , l2if_secc_cnt[15:0]}),
        .q    	(l2if_err_cnt[17:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, [15:0]}),
        .q    	([17:0]),
        .en     (),
        .clk    (clk));

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr),
        .clk    ());

// flop write and read valid
dffe_ns #(2)    l2if_ucb_rd_wr_vld(
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr));

dffe_ns #(2)    (
        .din    ({l2if_ucb_rd_req_vld_cpu, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr(
        .din    ({, l2if_ucb_wr_req_vld_cpu}),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr, }),
        .q      ({l2if_que_rd_req_vld, l2if_que_wr_req_vld}),
        .en     (l2if_dr}),
        .q      ({, l2if_que_wr_req_vld}),
        .en     (l2if_dr, }),
        .en     (l2if_dr}),
        .en     (),
        .clk    (clk));

// flop addr in
dffe_ns #(32)    l2if_ucb_addr_in(
        .din    (l2if_ucb_addr_cpu[31:0]),
        .q      (l2if_que_addr[31:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop data in
dffe_ns #(64)   l2if_ucb_data_in(
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop addr in
dffe_ns #(32)    l2if_ucb_addr_in(
        .din    (l2if_ucb_addr_cpu[31:0]),
        .q      (l2if_que_addr[31:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop data in
dffe_ns #(64)   l2if_ucb_data_in(
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(32)    (
        .din    (l2if_ucb_addr_cpu[31:0]),
        .q      (l2if_que_addr[31:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// flop data in
dffe_ns #(64)   l2if_ucb_data_in(
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([31:0]),
        .q      ([31:0]),
        .en     (),
        .clk    (clk));

// flop data in
dffe_ns #(64)   l2if_ucb_data_in(
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop data in
dffe_ns #(64)   l2if_ucb_data_in(
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64)   (
        .din    (l2if_ucb_data_cpu[63:0]),
        .q      (l2if_que_data[63:0]),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([63:0]),
        .q      ([63:0]),
        .en     (),
        .clk    (clk));

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// Freq 200 sel 
dffe_ns #(1)    ff_test_signals(
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1)    (
        .din    ({l2if_selfrsh}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ({}),
        .q      ({l2if_que_selfrsh}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .q      ({}),
        .en     (l2if_dram_tx_sync),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .en     (),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

//////////////////////////////////////////////////////////////////
// SIGNALS FROM JBUS TO CPU CLK
//////////////////////////////////////////////////////////////////

// Test signals
dffe_ns #(1) 	ff_ucb_test_signals(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));


dffe_ns #(1) 	(
        .din	({ucb_l2if_selfrsh}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({}),
        .q	({l2if_selfrsh}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .q	({}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
	.en	(),
        .clk	(clk));

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop write and read valid
dffe_ns #(2) 	ucb_rd_wr_vld(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(2) 	(
        .din	({ucb_dram_rd_req_vld, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({, ucb_dram_wr_req_vld}),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
        .q	({l2if_ucb_rd_req_vld, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .q	({, l2if_ucb_wr_req_vld}),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
	.en	(),
        .clk	(clk));

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop addr in
dffe_ns #(32) 	ucb_addr_in(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(32) 	(
        .din	(ucb_dram_addr[31:0]),
        .q	(l2if_ucb_addr[31:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	([31:0]),
        .q	([31:0]),
	.en	(),
        .clk	(clk));

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop data in
dffe_ns #(64) 	ucb_data_in(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64) 	(
        .din	(ucb_dram_data[63:0]),
        .q	(l2if_ucb_data[63:0]),
	.en	(l2if_jbus_rx_sync),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	([63:0]),
        .q	([63:0]),
	.en	(),
        .clk	(clk));

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

////////////////////////
// Flop enable so that its reset on dram sync pulse
////////////////////////

wire l2if_ucb_wr_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));


wire  = l2if_jbus_rx_sync_d1 & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & l2if_ucb_wr_req_vld;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ;
wire l2if_ucb_rd_req_vld_en = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec;
wire  = l2if_jbus_rx_sync_d1 & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & l2if_ucb_rd_req_vld;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ;
wire l2if_ucb_wr_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec;
wire  = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & ~(l2if_dram_tx_sync & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ~( & l2if_ucb_wr_req_vld_cpu);
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & );
wire l2if_ucb_rd_req_rst_l = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec);
wire  = rst_l & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & ~(l2if_dram_tx_sync & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ~( & l2if_ucb_rd_req_vld_cpu);

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & );

// flop write valid
dffrle_ns #(1)    l2if_wr_vld(
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec);

dffrle_ns #(1)    (
        .din    (l2if_ucb_wr_req_vld),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q      (l2if_ucb_wr_req_vld_cpu),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q      (),
        .en     (l2if_ucb_wr_req_vld_en),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
	.rst_l	(l2if_ucb_wr_req_rst_l),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.rst_l	(),
        .clk    (clk));

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop read valid
dffrle_ns #(1)    l2if_rd_vld(
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffrle_ns #(1)    (
        .din    (l2if_ucb_rd_req_vld),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q      (l2if_ucb_rd_req_vld_cpu),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q      (),
        .en     (l2if_ucb_rd_req_vld_en),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
	.rst_l	(l2if_ucb_rd_req_rst_l),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.rst_l	(),
        .clk    (clk));

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

wire l2if_ucb_addr_en = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

wire  = l2if_ucb_wr_req_vld_en | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  | l2if_ucb_rd_req_vld_en;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec | ;

// flop addr in
dffe_ns #(32)  ff_l2if_ucb_addr_cpu(
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec;

dffe_ns #(32)  (
        .din    (l2if_ucb_addr[31:0]),
        .q      (l2if_ucb_addr_cpu[31:0]),
        .en     (l2if_ucb_addr_en),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([31:0]),
        .q      ([31:0]),
        .en     (),
        .clk    (clk));

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop data in
dffe_ns #(64)   ff_l2if_ucb_data_cpu(
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64)   (
        .din    (l2if_ucb_data[63:0]),
        .q      (l2if_ucb_data_cpu[63:0]),
        .en     (l2if_ucb_wr_req_vld),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([63:0]),
        .q      ([63:0]),
        .en     (),
        .clk    (clk));

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

/////////////////////////////////////////////////
// SIGNALS FROM DRAM CLK TO CPU CLK
/////////////////////////////////////////////////

// Select bank bits
dffe_ns #(1) bank_bits_sel (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));


dffe_ns #(1)  (
        .din(que_addr_bank_low_sel),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec (
        .din(),
        .q(l2if_addr_bank_low_sel),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q(),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en(),
        .clk(clk));

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk());

// channel disable bit
dffe_ns #(1) ch_disabled (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1)  (
        .din(que_channel_disabled),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec (
        .din(),
        .q(l2if_channel_disabled),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q(),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en(),
        .clk(clk));

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk());

// 8 bank mode bit
dffe_ns #(1) eight_bank_mode (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1)  (
        .din(que_eight_bank_mode),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec (
        .din(),
        .q(l2if_eight_bank_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q(),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en(),
        .clk(clk));

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk());

// fail over bit
dffe_ns #(1) fail_over_mode (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1)  (
        .din(dram_fail_over_mode),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec (
        .din(),
        .q(l2if_dram_fail_over_mode),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q(),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en(),
        .clk(clk));

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk());

// Flop scrb address input
dffe_ns #(33) scrb_addr (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(33)  (
        .din(que_scrb_addr[32:0]),
        .q(l2if_scrb_addr[32:0]),
	.en(l2if_dram_rx_sync),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec (
        .din([32:0]),
        .q([32:0]),
	.en(),
        .clk(clk));

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk());

// dram to cpu clk domain of the buffer valids
dffe_ns #(17) ff_que_val(
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(17) (
        .din    ({que_wr_req, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ({, readqbank0vld0, readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , readqbank0vld1, readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , readqbank0vld2, readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , readqbank0vld3, 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , 
		writeqbank0vld0, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, 
		, writeqbank0vld1, writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , writeqbank0vld2, writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , writeqbank0vld3,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, ,
		readqbank0vld4, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec,
		, readqbank0vld5, readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , readqbank0vld6, readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , readqbank0vld7, 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , 
		writeqbank0vld4, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, 
		, writeqbank0vld5, writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , writeqbank0vld6, writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , writeqbank0vld7 }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec,  }),
        .q      ({l2if_new_wr_req_ret, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec }),
        .q      ({, l2if_b0_rd_val[3:0],l2if_b0_wr_val[3:0],
			l2if_b1_rd_val[3:0],l2if_b1_wr_val[3:0]}),
	.en(l2if_dram_rx_sync),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, [3:0],[3:0],
			[3:0],[3:0]}),
	.en(),
        .clk    (clk));

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

dffrle_ns #(12) l2_read_info(
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffrle_ns #(12) (
        .din	({que_dram_clk_toggle, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({, dp_data_valid, que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , que_l2if_send_info[9:0]}),
        .q	({l2if_dram_clk_toggle, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, [9:0]}),
        .q	({, dp_data_valid_d1, l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, , l2if_send_info[9:0]}),
	.rst_l	(rst_l),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, [9:0]}),
	.rst_l	(),
	.en 	(l2if_dram_rx_sync),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en 	(),
        .clk	(clk));

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop dp data to send to l2
dffe_ns #(288) l2_read_data(
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(288) (
        .din	({dp_ecc_in[31:0], dp_data_in[255:0]}),
        .q	({l2if_rd_ecc_p1[31:0], l2if_rd_data_p1[255:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({[31:0], [255:0]}),
        .q	({[31:0], [255:0]}),
	.en	(),
        .clk	(clk));

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop write data entry free
dffe_ns #(4) 	wr_entry_free(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(4) 	(
        .din	(que_wr_entry_free[3:0]),
        .q	(l2if_wr_entry_free[3:0]),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	([3:0]),
        .q	([3:0]),
	.en	(),
        .clk	(clk));

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop chip config for ras cas width and stack dimm 
dffe_ns #(10) 	ff_config(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(10) 	(
        .din	({que_rank1_present, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({, config_reg[8:0]}),
        .q	({rank1_present, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, [8:0]}),
        .q	({, l2if_config_reg[8:0]}),
	.en	(l2if_dram_rx_sync),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, [8:0]}),
	.en	(),
        .clk	(clk));

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop ack and nack
dffe_ns #(2)    l2if_ucb_ack_nack(
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(2)    (
        .din    ({que_l2if_ack_vld, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ({, que_l2if_nack_vld}),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
        .q      ({l2if_ucb_ack_vld, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .q      ({, l2if_ucb_nack_vld}),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .en     (),
        .clk    (clk));

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop data
dffe_ns #(64)   l2if_ucb_data_out(
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64)   (
        .din    (que_l2if_data[63:0]),
        .q      (l2if_ucb_que_data[63:0]),
        .en     (l2if_dram_rx_sync),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([63:0]),
        .q      ([63:0]),
        .en     (),
        .clk    (clk));

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

////////////////////////////////////////
// Flop enable so that its reset on jbus sync pulse
////////////////////////////////////////

wire l2if_ucb_ack_en = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));


wire  = l2if_dram_rx_sync_d1 & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & l2if_ucb_ack_vld;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ;
wire l2if_ucb_nack_en = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec;
wire  = l2if_dram_rx_sync_d1 & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & l2if_ucb_nack_vld;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ;
wire l2if_ucb_ack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec;
wire  = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & ~(l2if_jbus_tx_sync & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ~( & l2if_ucb_ack_vld_cpu);
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & );
wire l2if_ucb_nack_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec);
wire  = rst_l & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & ~(l2if_jbus_tx_sync & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ~( & l2if_ucb_nack_vld_cpu);
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & );
wire l2if_secc_trig_rst_l = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec);
wire  = rst_l & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec =  & ~(l2if_jbus_tx_sync & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & ~( & l2if_trig);

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec & );

// flop ack 
dffrle_ns #(1)  ucb_ack(
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec);

dffrle_ns #(1)  (
        .din    (l2if_ucb_ack_vld),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q      (l2if_ucb_ack_vld_cpu),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q      (),
        .en     (l2if_ucb_ack_en),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
	.rst_l	(l2if_ucb_ack_rst_l),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.rst_l	(),
        .clk    (clk));

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop nack 
dffrle_ns #(1)  ucb_nack(
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffrle_ns #(1)  (
        .din    (l2if_ucb_nack_vld),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q      (l2if_ucb_nack_vld_cpu),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q      (),
        .en     (l2if_ucb_nack_en),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
	.rst_l	(l2if_ucb_nack_rst_l),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.rst_l	(),
        .clk    (clk));

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop data
dffe_ns #(64)   ucb_data_cpu(
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64)   (
        .din    (l2if_ucb_que_data[63:0]),
        .q      (l2if_ucb_que_data_cpu[63:0]),
        .en     (l2if_ucb_ack_en),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    ([63:0]),
        .q      ([63:0]),
        .en     (),
        .clk    (clk));

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop dbg_trig 
dffrle_ns #(1)  ff_dgb_trig(
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffrle_ns #(1)  (
        .din    (l2if_secc_trig),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q      (l2if_trig),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q      (),
        .en     (l2if_secc_trig),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
	.rst_l	(l2if_secc_trig_rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.rst_l	(),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

//////////////////////////////////////////////////////////////////
// SIGNALS FROM CPU TO JBUS CLK
//////////////////////////////////////////////////////////////////

// flop ack and nack 
dffe_ns #(2) 	ucb_ack_nack(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));


dffe_ns #(2) 	(
        .din	({l2if_ucb_ack_vld_cpu, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	({, l2if_ucb_nack_vld_cpu}),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
        .q	({dram_ucb_ack_vld, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
        .q	({, dram_ucb_nack_vld}),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec, }),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec}),
	.en	(),
        .clk	(clk));

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// flop data
dffe_ns #(64) 	ucb_data_out(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(64) 	(
        .din	(l2if_ucb_que_data_cpu[63:0]),
        .q	(dram_ucb_data[63:0]),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	([63:0]),
        .q	([63:0]),
	.en	(),
        .clk	(clk));

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

// err interrupt
dffe_ns #(1) 	ff_err_intr(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1) 	(
        .din    (l2if_secc_cnt_intr),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din    (),
        .q    	(l2if_err_intr),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q    	(),
        .en     (l2if_jbus_tx_sync),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .en     (),
        .clk    (clk));

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk    ());

// flop debug trigger
dffe_ns #(1) 	dbg_trig(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));

dffe_ns #(1) 	(
        .din	(l2if_trig),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec(
        .din	(),
        .q	(l2if_ucb_trig),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .q	(),
	.en	(l2if_jbus_tx_sync),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
	.en	(),
        .clk	(clk));

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec),
        .clk	());

//////////////////////////////////////////////////////////////////
// Generate the ack for L2
//////////////////////////////////////////////////////////////////

// There could be corner case in writes due to more than 8 requests
// being asserted unlike in reads due to no id numbers. 

// Need to count only for write not for read bec));




assign [3:0] = {3hh, [3]} + {3hh, [2]} + 
				{3hh, [1]} + {3hh, [0]} + 
				{3hh, [3]} + {3hh, [2]} +
				{3hh, [1]}+ {3hh, [0]};


assign  = ( (~l2if_wr_val_cnt[3] & ~(&l2if_wr_val_cnt[2:0])) | 
			(&l2if_wr_val_cnt[2:0] & ~(l2if_wr_req | l2if_new_wr_req_ret)) ) & 
				l2if_wr_req_cpu & l2if_dram_tx_sync; 

assign l2if_rd_ack = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = ( (~[3] & ~(&[2:0])) | 
			(&[2:0] & ~( | l2if_new_wr_req_ret)) ) & 
				l2if_wr_req_cpu & l2if_dram_tx_sync; 

assign l2if_rd_ack = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  | )) ) & 
				l2if_wr_req_cpu & l2if_dram_tx_sync; 

assign l2if_rd_ack = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = )) ) & 
				 & l2if_dram_tx_sync; 

assign l2if_rd_ack = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ; 

assign l2if_rd_ack = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ; 

assign  = ~(&{l2if_b0_rd_val[3:0],l2if_b1_rd_val[3:0]}) & 
				l2if_rd_req_cpu & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = ~(&{[3:0],[3:0]}) & 
				 & l2if_dram_tx_sync |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  |
		~l2if_channel_disabled & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  |
		~ & ~dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
				 & l2if_rd_dummy_req_p1 |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  |
		l2if_channel_disabled & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  |
		 & ~ch0_dp_data_valid_d1 & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_dram_rx_sync_d1 & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & 
				l2if_dram_rd_req & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
				 & l2if_rd_dummy_req_p1; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ; 

// Read Ack 
dffrl_ns 	ff_rd_ack0(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ; 

dffrl_ns 	(
        .din    (l2if_rd_ack),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din    (),
        .q      (dram_sctag_rd_ack),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q      (),
	.rst_l  (rst_l),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
	.rst_l  (),
        .clk    (clk));

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk    ());

// Write Ack logic
dffrl_ns 	ff_wr_ack(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

dffrl_ns 	(
        .din    (l2if_wr_ack),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din    (),
        .q      (dram_sctag_wr_ack),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q      (),
	.rst_l  (rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
	.rst_l  (),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk    ());

//////////////////////////////////////////////////////////////////
//// L2 Interface DP Portion (Possibly to Synthesize)
//////////////////////////////////////////////////////////////////

// Flop all data input
dff_ns #(64) l2dataflop0 (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));


dff_ns #(64)  (
        .din    (sctag_dram_wr_data[63:0]),
        .q      (dram_cpu_wr_data[63:0]),
        .clk    (clk));

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  (
        .din    ([63:0]),
        .q      ([63:0]),
        .clk    ());

dffrl_ns #(2) l2datavldflop (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

dffrl_ns #(2)  (
        .din    ({sctag_dram_data_vld, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  (
        .din    ({, sctag_dram_data_mecc}),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = , }),
        .q      ({l2if_b0_data_vld, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = }),
        .q      ({, l2if_dram_data_mecc}),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = , }),
	.rst_l	(rst_l),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = }),
	.rst_l	(),
        .clk    (clk));

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk    ());

// stage data valid 
dffrl_ns #(1) ff_data_vld (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

dffrl_ns #(1)  (
        .din    (l2if_b0_data_vld),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  (
        .din    (),
        .q    	(l2if_b0_data_vld_d1),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q    	(),
	.rst_l	(rst_l),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
	.rst_l	(),
        .clk    (clk));

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk    ());

//////////////////////////////////////////////////////////////////
// Generate address and enable for writing data into arrays.
//////////////////////////////////////////////////////////////////

// generate enable for write
assign dram_cpu_wr_en[3:0] = ~({4{l2if_b0_data_vld}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));


assign [3:0] = ~({4{}} & 
		({ l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & l2if_wr_b0_data_addr[0],
		   ~l2if_wr_b0_data_addr[1] & ~l2if_wr_b0_data_addr[0] }));

// generate the index into the array
// When data valid is high just increment the address to write into that location.
// When its low, eval only when the data valid is just gone low and there is no pending req at that time
// and also tha there is some entry empty. If all entries are occupied, then check for entry that's
// getting free and make that as free entry. By default it will keep its old value.
assign l2if_wr_b0_data_addr_in[5:0] = (~l2if_b0_data_vld) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = }} & 
		({ [1] & [0],
		   [1] & ~[0],
		   ~[1] & [0],
		   ~[1] & ~[0] }));

assign [5:0] = (~) ?  ( 
			~l2if_wr_entry0 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ) ?  ( 
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h0 :
			~l2if_wr_entry1 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h8 :
			~l2if_wr_entry2 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h10 :
			~l2if_wr_entry3 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h18 :
			~l2if_wr_entry4 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h20 :
			~l2if_wr_entry5 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h28 :
			~l2if_wr_entry6 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh :
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h30 : 
			~l2if_wr_entry7 & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh : 
			~ & ~l2if_wr_req_cpu & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & l2if_b0_data_vld_d1 ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  ? 6'h38 : 
		l2if_wr_entry0 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  ? 6hh : 
		 & l2if_wr_entry1 & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & l2if_wr_entry2 & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & l2if_wr_entry3 & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & 
		l2if_wr_entry4 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
		 & l2if_wr_entry5 & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & l2if_wr_entry6 & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & l2if_wr_entry7 & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & 
		l2if_wr_entry_free[3] ? {l2if_wr_entry_free[2:0],3'h0} : 
			l2if_wr_b0_data_addr[5:0]) : l2if_wr_b0_data_addr[5:0] + 6'h1;

dffrl_ns #(6) ff_b0_data_addr (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
		[3] ? {[2:0],3hh} : 
			[5:0]) : [5:0] + 6hh;

dffrl_ns #(6)  (
        .din(l2if_wr_b0_data_addr_in[5:0]),
        .q(l2if_wr_b0_data_addr[5:0]),
	.rst_l(rst_l),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  (
        .din([5:0]),
        .q([5:0]),
	.rst_l(),
        .clk(clk));

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

assign dram_cpu_wr_addr = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

assign  = l2if_wr_b0_data_addr[5:2];

// Keep track of in use entries. A 1 means its in use or else free.
// Keep it free if there was address error in write address. The write is silently dropped.
wire l2if_wr_entry0_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [5:2];

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) |
	 		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
	 		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
				(l2if_wr_b0_data_addr[5:3] == 3'h0);
wire l2if_wr_entry0_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
				([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h0) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent0(
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry0_in),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry0),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
	.rst_l(rst_l),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
	.rst_l(),
	.en(l2if_wr_entry0_en),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
	.en(),
        .clk(clk));

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry1_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h1);
wire l2if_wr_entry1_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h1) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent1(
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry1_in),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry1),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry1_en),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry2_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h2);
wire l2if_wr_entry2_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h2) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent2(
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry2_in),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry2),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry2_en),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry3_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) |
	  		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
	  		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h3);
wire l2if_wr_entry3_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h3) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent3(
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry3_in),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry3),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry3_en),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry4_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h4);
wire l2if_wr_entry4_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h4) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent4(
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry4_in),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry4),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry4_en),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry5_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h5);
wire l2if_wr_entry5_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h5) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent5(
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry5_in),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry5),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry5_en),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry6_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h6);
wire l2if_wr_entry6_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h6) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent6(
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry6_in),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry6),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry6_en),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

wire l2if_wr_entry7_en = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));

wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) |
         		~l2if_wr_addr_err & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) |
         		~ & l2if_b0_data_vld & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  &  & ~l2if_b0_data_vld_d1 & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & ~ & 
			(l2if_wr_b0_data_addr[5:3] == 3'h7);
wire l2if_wr_entry7_in = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  & 
			([5:3] == 3hh);
wire  = l2if_wr_entry_free[3] & (l2if_wr_entry_free[2:0] == 3'h7) ? 1'b0 : 1'b1;

dffrle_ns #(1) ff_wr_ent7(
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in =  = [3] & ([2:0] == 3hh) ? 1bb : 1bb;

dffrle_ns #(1) (
        .din(l2if_wr_entry7_in),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = (
        .din(),
        .q(l2if_wr_entry7),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .q(),
        .rst_l(rst_l),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .rst_l(),
        .en(l2if_wr_entry7_en),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .en(),
        .clk(clk));

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ),
        .clk());

//////////////////////////////////////////////////////////////////
// Generate L2 response for read requests
//////////////////////////////////////////////////////////////////

///////
// Generate chunk offset
///////

assign l2if_data_cnt_in = ));



assign  =  =  + 2'h1;
assign l2if_data_cnt_en = l2if_data_cnt_val | l2if_dummy_data_cnt_val;

dffrle_ns #(2) ff_data8_cnt(
        .din(l2if_data_cnt_in[1:0]),
        .q(l2if_data_cnt[1:0]),
	.rst_l(rst_l),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr + 2hh;
assign  = l2if_data_cnt_val | l2if_dummy_data_cnt_val;

dffrle_ns #(2) ff_data8_cnt(
        .din(l2if_data_cnt_in[1:0]),
        .q(l2if_data_cnt[1:0]),
	.rst_l(rst_l),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr =  | l2if_dummy_data_cnt_val;

dffrle_ns #(2) ff_data8_cnt(
        .din(l2if_data_cnt_in[1:0]),
        .q(l2if_data_cnt[1:0]),
	.rst_l(rst_l),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr | ;

dffrle_ns #(2) ff_data8_cnt(
        .din(l2if_data_cnt_in[1:0]),
        .q(l2if_data_cnt[1:0]),
	.rst_l(rst_l),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr;

dffrle_ns #(2) (
        .din(l2if_data_cnt_in[1:0]),
        .q(l2if_data_cnt[1:0]),
	.rst_l(rst_l),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr(
        .din([1:0]),
        .q([1:0]),
	.rst_l(),
	.en(l2if_data_cnt_en),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
	.en(),
        .clk(clk));

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .clk());

// Stage data valid 
// Data correction and detection is for two cycles.

dff_ns #(1) ff_data_vld_d1(
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr));


dff_ns #(1) (
        .din(dp_data_valid_d1),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr(
        .din(),
        .q(l2if_data_valid_d1),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .q(),
        .clk(clk));

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .clk());

// This signal aligns with the data out of ecc_corection module
dff_ns #(1) ff_data_vld_d2(
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr));

dff_ns #(1) (
        .din(l2if_data_valid_d1),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr(
        .din(),
        .q(l2if_data_valid_d2),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .q(),
        .clk(clk));

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .clk());

// This signal aligns with the flopped data out of ecc_corection module
dff_ns #(1) ff_data_vld_d3(
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr));

dff_ns #(1) (
        .din(l2if_data_valid_d2),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr(
        .din(),
        .q(l2if_data_valid_d3),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .q(),
        .clk(clk));

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr),
        .clk());

// Because the valid signal in cpu clk domain is valid for multiple cycles, we
// have reset the valid after one cpu cycle. Also note that valid would not
// asserted back to back cycles as CAS is not picked back to back cycles.

assign l2if_add_fifo_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr));


assign  = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr = ~( == l2if_dram_clk_toggle) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr == ) & l2if_send_info[6];
assign l2if_add_scrb_valid = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr) & [6];
assign  = ~(l2if_dram_clk_toggle_d1 == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr = ~( == l2if_dram_clk_toggle) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr == ) & l2if_send_info[5];

// This part of code is keeping the 8 deep FIFO that expects the first data to come back
reg	l2if_fifo_ent0_en;
reg	l2if_fifo_ent1_en;
reg	l2if_fifo_ent2_en;
reg	l2if_fifo_ent3_en;
reg	l2if_fifo_ent4_en;
reg	l2if_fifo_ent5_en;
reg	l2if_fifo_ent6_en;
reg	l2if_fifo_ent7_en;

always @(l2if_add_fifo_valid or l2if_fifo_ent0 or l2if_fifo_ent1 or l2if_fifo_ent2 or
	l2if_fifo_ent3 or l2if_fifo_ent4 or l2if_fifo_ent5 or l2if_fifo_ent6 or l2if_fifo_ent7)
begin
	l2if_fifo_ent7_en = 1'b0;
	l2if_fifo_ent6_en = 1'b0;
	l2if_fifo_ent5_en = 1'b0;
	l2if_fifo_ent4_en = 1'b0;
	l2if_fifo_ent3_en = 1'b0;
	l2if_fifo_ent2_en = 1'b0;
	l2if_fifo_ent1_en = 1'b0;
	l2if_fifo_ent0_en = 1'b0;
	if(~l2if_fifo_ent7[6] & ~l2if_fifo_ent7[5]) begin
		l2if_fifo_ent7_en = 1'b1;
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent6[6] & ~l2if_fifo_ent6[5]) begin
		l2if_fifo_ent6_en = 1'b1;
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent5[6] & ~l2if_fifo_ent5[5]) begin
		l2if_fifo_ent5_en = 1'b1;
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent4[6] & ~l2if_fifo_ent4[5]) begin
		l2if_fifo_ent4_en = 1'b1;
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent3[6] & ~l2if_fifo_ent3[5]) begin
		l2if_fifo_ent3_en = 1'b1;
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent2[6] & ~l2if_fifo_ent2[5]) begin
		l2if_fifo_ent2_en = 1'b1;
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(~l2if_fifo_ent1[6] & ~l2if_fifo_ent1[5]) begin
		l2if_fifo_ent1_en = 1'b1;
		l2if_fifo_ent0_en = 1'b1;
	end
	else if(l2if_add_fifo_valid) begin
		l2if_fifo_ent0_en = 1'b1;
	end

end

dffrle_ns #(10) l2_fifo_ent0(
        .din({l2if_send_info[9:7], l2if_add_fifo_valid, l2if_add_scrb_valid, l2if_send_info[4:0]}),
        .q(l2if_fifo_ent0[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent0_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent1(
        .din(l2if_fifo_ent0[9:0]),
        .q(l2if_fifo_ent1[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent1_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent2(
        .din(l2if_fifo_ent1[9:0]),
        .q(l2if_fifo_ent2[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent2_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent3(
        .din(l2if_fifo_ent2[9:0]),
        .q(l2if_fifo_ent3[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent3_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent4(
        .din(l2if_fifo_ent3[9:0]),
        .q(l2if_fifo_ent4[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent4_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent5(
        .din(l2if_fifo_ent4[9:0]),
        .q(l2if_fifo_ent5[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent5_en),
        .clk(clk));

dffrle_ns #(10) l2_fifo_ent6(
        .din(l2if_fifo_ent5[9:0]),
        .q(l2if_fifo_ent6[9:0]),
	.rst_l(rst_l),
	.en(l2if_fifo_ent6_en),
        .clk(clk));

assign l2if_data_valid_reset = l2if_fifo_reset | ~rst_l;

dffrle_ns #(10) l2_fifo_ent7(
        .din(l2if_fifo_ent6[9:0]),
        .q(l2if_fifo_ent7[9:0]),
	.rst_l(~l2if_data_valid_reset),
	.en(l2if_fifo_ent7_en),
        .clk(clk));

///////
// Stage the toggle to detect the dram clk transition 
// Three stages due to 2 for valids in one dram clk and one becuase 
// data_valid is also delayed for one cycle due to data delay of 1 cycle to valid.
///////

dff_ns #(1) l2_data_valid(
        .din(l2if_dram_clk_toggle),
        .q(l2if_dram_clk_toggle_d1),
        .clk(clk));

dff_ns #(1) l2_data_valid_d1(
        .din(l2if_dram_clk_toggle_d1),
        .q(l2if_dram_clk_toggle_d2),
        .clk(clk));

//////////////////////////////////////
// VALID and OFFSET generation 
//////////////////////////////////////

// To have 2 consecutive cycles of valid, got to use d1 and d3.
assign l2if_data_cnt_val = dp_data_valid_d1 & 
				~(l2if_dram_clk_toggle_d2 == l2if_dram_clk_toggle);
 
// Assert valid only when there is no data valid from dp and start of new cycle or data.
assign l2if_dummy_data_cnt_val = (~l2if_channel_disabled & ~dp_data_valid_d1 |
				l2if_channel_disabled & ~ch0_dp_data_valid_d1) & 
				(l2if_dram_rx_sync_d1 & l2if_dram_rd_req & 
				l2if_rd_dummy_req_p1 | (|l2if_data_cnt) );

assign l2if_data_offset[1:0] = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_chunk_id : 
			(l2if_data_cnt[1:0] == 2'h0) & l2if_data_cnt_val ? 
		l2if_fifo_ent7[1:0] : (l2if_data_cnt[1:0] == 2'h0) & 
			~l2if_data_cnt_val & l2if_dummy_data_cnt_val ? l2if_rd_addr_p1[5:4] :
			dram_sctag_chunk_id[1:0] + {1'b0,l2if_offset_inc};

assign l2if_data_mux_sel_en = l2if_data_cnt_val & (l2if_fifo_ent7[6] | l2if_fifo_ent7[5]) | // loads | scrub
				l2if_dummy_data_cnt_val;
wire l2if_offset_inc_in = l2if_data_cnt_val & l2if_fifo_ent7[6] |
				l2if_dummy_data_cnt_val;

assign l2if_l2_val = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_data_val_other_ch : 
				l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				(l2if_channel_disabled == l2if_fifo_ent7[8]) |
				l2if_dummy_data_cnt_val;

wire l2if_l2_val_other_ch = l2if_data_cnt_val & l2if_fifo_ent7[6] & 
				~(l2if_channel_disabled == l2if_fifo_ent7[8]);
wire [2:0] l2if_rd_req_id = l2if_channel_disabled & ch0_dp_data_valid_d1 ? 
				ch0_dram_sctag_rd_req_id[2:0] : 
				l2if_data_cnt_val ? l2if_fifo_ent7[4:2] :
				l2if_rd_id_p1[2:0];
wire l2if_pa_err_val = l2if_data_cnt_val & l2if_fifo_ent7[7] | 
				l2if_dummy_data_cnt_val & l2if_split_rd_addr[32];

dffrl_ns #(9) l2_read_response(
        .din({l2if_offset_inc_in, l2if_l2_val_other_ch, l2if_data_offset[1:0], l2if_l2_val, 
			l2if_pa_err_val, l2if_rd_req_id[2:0]}),
        .q({l2if_offset_inc, dram_data_val_other_ch, dram_sctag_chunk_id[1:0], dram_sctag_data_vld, 
			l2if_addr_err, dram_sctag_rd_req_id[2:0]}),
	.rst_l(rst_l),
        .clk(clk));

// Generate l2if_data_cnt_val for dequeing the 8 deep fifo
assign l2if_fifo_reset = (l2if_data_cnt == 2'h3) & l2if_data_cnt_val;

// Generate scrb_val for dram clk domain to flop data
// Needed to stage for 3 cycles to aligning with data and error signals

wire l2if_scrb_val = l2if_data_cnt_val & l2if_fifo_ent7[5];

dff_ns #(1) ff_scrb_val(
        .din(l2if_scrb_val),
        .q(l2if_scrb_val_d1),
        .clk(clk));

dff_ns #(1) ff_scrb_val_d1(
        .din(l2if_scrb_val_d1),
        .q(l2if_scrb_val_d2),
        .clk(clk));

wire l2if_scrb_val_d3_in = l2if_scrb_val_d2 & ~(l2if_dram_tx_sync & l2if_scrb_val_d3) ;
wire l2if_scrb_val_en = l2if_scrb_val_d3_in | l2if_dram_tx_sync & l2if_scrb_val_d3;

dffrle_ns #(1) ff_scr) & [5];

reg