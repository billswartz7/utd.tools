

    
module sparc_exu_ecl_mdqctl (
      mdqctl_divcntl_input_vld, mdqctl_divcntl_reset_div, 
   mdqctl_divcntl_muldone, ecl_div_div64, ecl_div_signed_div, 
   ecl_div_muls, mdqctl_wb_divthr_g, mdqctl_wb_divrd_g, 
   mdqctl_wb_multhr_g, mdqctl_wb_mulrd_g, mdqctl_wb_divsetcc_g, 
   mdqctl_wb_mulsetcc_g, mdqctl_wb_yreg_shift_g, exu_mul_input_vld, 
   mdqctl_wb_yreg_wen_g, ecl_div_mul_sext_rs1_e, 
   ecl_div_mul_sext_rs2_e, ecl_div_mul_get_new_data, 
   ecl_div_mul_keep_data, ecl_div_mul_get_32bit_data, 
   ecl_div_mul_wen, div_zero_m, 
      clk, se, reset, ifu_exu_muldivop_d, tid_d, ifu_exu_rd_d, tid_w1, 
   flush_w1, ifu_exu_inst_vld_w, wb_divcntl_ack_g, divcntl_wb_req_g, 
   byp_alu_rs1_data_31_e, byp_alu_rs2_data_31_e, mul_exu_ack, 
   ecl_div_sel_div, ifu_exu_muls_d, div_ecl_detect_zero_high, 
   div_ecl_detect_zero_low, ifu_tlu_flush_w, early_flush_w
   ) ;
   input clk;
   input se;
   input reset;
   input [4:0] ifu_exu_muldivop_d;
   input [1:0] tid_d;
   input [4:0] ifu_exu_rd_d;
   input [1:0] tid_w1;
   input       flush_w1;
   input       ifu_exu_inst_vld_w;
   input       wb_divcntl_ack_g;
   input       divcntl_wb_req_g;
   input       byp_alu_rs1_data_31_e;
   input       byp_alu_rs2_data_31_e;
   input       mul_exu_ack;
   input       ecl_div_sel_div;
   input       ifu_exu_muls_d;
   input       div_ecl_detect_zero_high;
   input       div_ecl_detect_zero_low;
   input       ifu_tlu_flush_w;
   input       early_flush_w;

   
   output      mdqctl_divcntl_input_vld;
   output      mdqctl_divcntl_reset_div;
   output      mdqctl_divcntl_muldone;
   output      ecl_div_div64;
   output      ecl_div_signed_div;
   output      ecl_div_muls;
   output [1:0] mdqctl_wb_divthr_g;
   output [4:0] mdqctl_wb_divrd_g;
   output [1:0] mdqctl_wb_multhr_g;
   output [4:0] mdqctl_wb_mulrd_g;
   output       mdqctl_wb_divsetcc_g;
   output       mdqctl_wb_mulsetcc_g;
   output       mdqctl_wb_yreg_shift_g;

   
   output       exu_mul_input_vld;
   output       mdqctl_wb_yreg_wen_g;
   output       ecl_div_mul_sext_rs1_e;
   output       ecl_div_mul_sext_rs2_e;
   output       ecl_div_mul_get_new_data;
   output       ecl_div_mul_keep_data;
   output       ecl_div_mul_get_32bit_data;
   output       ecl_div_mul_wen;
   output   div_zero_m;

   wire [11:0] ;
   wire [11:0] div_data;
   wire        new_div_vld;
   wire        curr_div_vld;
   wire [11:0] div_input_data_d;
   wire [9:0] mul_input_data_d;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire [11:0] ;
   wire        new_div_vld;
   wire        curr_div_vld;
   wire [11:0] div_input_data_d;
   wire [9:0] mul_input_data_d;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        curr_div_vld;
   wire [11:0] div_input_data_d;
   wire [9:0] mul_input_data_d;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire [11:0] div_input_data_d;
   wire [9:0] mul_input_data_d;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire [11:0] ;
   wire [9:0] mul_input_data_d;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire [9:0] ;
   wire [9:0] mul_data;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire [9:0] ;
   wire [9:0] mul_data_next;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire [9:0] ;
   wire        new_mul_d;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        kill_thr_mul;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_kill;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        invalid_mul_w;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        div_kill;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        kill_thr_div;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   
   wire        mul_ready_next;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   
   wire        ;
   wire        mul_ready;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_valid_c0;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_valid_c1;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_ack;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_c0;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_c1;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_c2;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done_c3;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;

   wire        isdiv_e_valid;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;

   wire        ;
   wire        isdiv_m_valid;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        ismul_e_valid;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        ismul_m_valid;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        isdiv_e;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        isdiv_m;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        isdiv_w;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        ismul_e;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        ismul_m;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        ismul_w;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   
   wire        div_used;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   
   wire        ;
   wire        invalid_div_w;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        div_zero_e;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;

   // Mul result state wires
   wire        go_mul_done;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;

      wire        ;
   wire        stay_mul_done;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        mul_done;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   wire        next_mul_done;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   wire        ;
   
   
   ////////////////////////
   // Divide  output DATAPATH
   ////////////////////////
   // store control signals
   assign div_used = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;
   
   
               assign  = divcntl_wb_req_g & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 =  & wb_divcntl_ack_g & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 &  & ecl_div_sel_div;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 & ;

   assign new_div_vld = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1;

   assign  = ifu_exu_muls_d | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 =  | ifu_exu_muldivop_d[3];
   
   assign div_input_data_d[11:0] = {1'b1, // isdiv
                                    ifu_exu_muls_d,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 | [3];
   
   assign [11:0] = {1bb,                                     ,
                                    ifu_exu_muldivop_d[2], // 64bit
                                    ifu_exu_muldivop_d[1], // signed
                                    ifu_exu_muldivop_d[0], // setcc
                                    ifu_exu_rd_d[4:0],
                                    tid_d[1:0]};
   mux2ds #(12) div_data_mux(.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1,
                                    [2],                                     [1],                                     [0],                                     [4:0],
                                    [1:0]};
   mux2ds #(12) (.dout(div_data_next[11:0]),
                                .in0({curr_div_vld, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1(.dout([11:0]),
                                .in0({, div_data[10:0]}),
                                .in1(div_input_data_d[11:0]),
                                .sel0(~new_div_vld),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1, [10:0]}),
                                .in1([11:0]),
                                .sel0(~),
                                .sel1(new_div_vld));

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1),
                                .sel1());

   dffr_s #(12) div_data_dff(.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1));

   dffr_s #(12) (.din(div_data_next[11:0]), .clk(clk), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1(.din([11:0]), .clk(), .q(div_data[11:0]),
                          .se(se), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1), .q([11:0]),
                          .se(), .si(), .so(), .rst(reset));

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1), .si(), .so(), .rst());

   //div  kill logic (kills on div by zero exception or if there isn't an outstanding div)
   assign div_zero_e = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1));

      assign  = isdiv_e & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 =  & div_ecl_detect_zero_high & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 &  & div_ecl_detect_zero_low & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 &  & ~div_data[`MULS];
   assign invalid_div_w = isdiv_w & (~ifu_exu_inst_vld_w | ifu_tlu_flush_w | early_flush_w);
   assign kill_thr_div = ~(div_data[1] ^ tid_w1[1]) & ~(div_data[0] ^ tid_w1[0]);
   assign div_kill = (flush_w1 & kill_thr_div) | invalid_div_w | new_div_vld;
   assign curr_div_vld = div_data[11] & ~div_zero_m & ~div_kill & ~div_used;

   wire   div_zero_unqual_m;
   assign div_zero_m = div_zero_unqual_m & isdiv_m;
   dff_s div_zero_e2m(.din(div_zero_e), .clk(clk), .q(div_zero_unqual_m), .se(se), .si(), .so());
   
   // pipeling for divide valid signal (for inst_vld checking)
   dff_s isdiv_d2e(.din(new_div_vld), .clk(clk), .q(isdiv_e),
                 .se(se), .si(), .so());
   dff_s isdiv_e2m(.din(isdiv_e_valid), .clk(clk), .q(isdiv_m),
                 .se(se), .si(), .so());
   dff_s isdiv_m2w(.din(isdiv_m_valid), .clk(clk), .q(isdiv_w),
                 .se(se), .si(), .so());
   assign        isdiv_e_valid = isdiv_e & ~div_kill;
   assign        isdiv_m_valid = isdiv_m & ~div_kill;

   // control for div state machine
   assign mdqctl_divcntl_reset_div = (~div_data[11] | div_kill);
   assign mdqctl_divcntl_input_vld = isdiv_e;

   // control signals for div
   assign ecl_div_div64 = div_data[`IS64];
   assign ecl_div_signed_div = div_data[`SIGNED];
   assign ecl_div_muls = div_data[`MULS];
   
   // control for writeback on completion
   assign mdqctl_wb_divrd_g[4:0] = div_data[6:2];
   assign mdqctl_wb_divthr_g[1 & ~