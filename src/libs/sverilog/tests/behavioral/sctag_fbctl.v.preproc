 
 



module sctag_fbctl( 
      fbctl_fbtag_wr_ptr, fbctl_fbtag_wr_en, fbctl_buf_rd_en, 
   fbctl_fbtag_rd_ptr, so, fbctl_tagctl_hit_c2, fbctl_fbd_rd_en_c2, 
   fbctl_fbd_rd_entry_c2, dram_sctag_chunk_id_r1, 
   dram_sctag_data_vld_r1, fbctl_fbd_wr_entry_r1, 
   sctag_dram_rd_req_id, fb_count_eq_0, fbctl_mbctl_entry_avail, 
   fbctl_mbctl_match_c2, fbctl_mbctl_fbid_d2, fbf_enc_ld_mbid_r1, 
   fbf_ready_miss_r1, fbf_enc_dep_mbid_c4, fbf_st_or_dep_rdy_c4, 
   fbctl_mbctl_nofill_d2, fbctl_mbctl_stinst_match_c2, 
   scdata_fb_hit_c3, fbctl_vuad_bypassed_c3, fbctl_arb_l2rd_en, 
   fbctl_arbdp_way_px2, fbctl_arbdp_tecc_px2, fbctl_arbdp_entry_px2, 
   fbctl_arbctl_vld_px1, fbctl_corr_err_c8, fbctl_uncorr_err_c8, 
   dram_scb_mecc_err_d1, dram_scb_secc_err_d1, fbctl_spc_corr_err_c7, 
   fbctl_spc_uncorr_err_c7, fbctl_spc_rd_vld_c7, 
   fbctl_bsc_corr_err_c12, fbctl_ld64_fb_hit_c12, fbctl_dis_cerr_c3, 
   fbctl_dis_uerr_c3, 
      rdmard_cerr_c12, rdmard_uerr_c12, ev_cerr_r6, ev_uerr_r6, 
   rst_tri_en, mbctl_fbctl_next_vld_c4, mbctl_fbctl_next_link_c4, 
   mbf_delete_c4, mbctl_hit_c4, mbf_insert_c4, 
   mbdata_fbctl_mbf_entry, mbctl_fbctl_dram_pick, mbctl_fbctl_fbid, 
   mbctl_fbctl_way, mbctl_fbctl_way_fbid_vld, mbf_insert_mbid_c4, 
   mbdata_fbctl_rqtyp_d1, mbdata_fbctl_rsvd_d1, decdp_imiss_inst_c2, 
   arbdp_inst_mb_entry_c1, decdp_cas1_inst_c2, arbdp_rdma_inst_c1, 
   mbctl_rdma_reg_vld_c2, decc_scrd_uncorr_err_c8, 
   decc_scrd_corr_err_c8, decc_bscd_corr_err_c8, 
   decc_bscd_uncorr_err_c8, tag_error_c8, tagctl_rd64_complete_c11, 
   cerr_ack_tmp_c4, uerr_ack_tmp_c4, spc_rd_cond_c3, 
   csr_fbctl_scrub_ready, arbctl_fbctl_fbsel_c1, arbctl_fill_vld_c2, 
   arbctl_fbctl_hit_off_c1, arbctl_fbctl_inst_vld_c2, 
   decdp_wr8_inst_c2, arbdp_inst_mb_c2, decdp_ld64_inst_c2, 
   fb_cam_match, l2_bypass_mode_on, l2_dir_map_on, 
   dram_sctag_data_vld_r0, dram_sctag_rd_req_id_r0, 
   dram_sctag_chunk_id_r0, dram_sctag_secc_err_r2, 
   dram_sctag_mecc_err_r2, dram_sctag_scb_mecc_err, 
   dram_sctag_scb_secc_err, tagctl_rdma_gate_off_c2, arst_l, grst_l, 
   dbginit_l, si, se, rclk
   );

input	rdmard_cerr_c12, rdmard_uerr_c12;
input	ev_cerr_r6, ev_uerr_r6;
input	rst_tri_en ;
output	[7:0]	fbctl_fbtag_wr_ptr; output		fbctl_fbtag_wr_en; output		fbctl_buf_rd_en;	output	[7:0]	fbctl_fbtag_rd_ptr ; output		so;

output		fbctl_tagctl_hit_c2 ;  
output		fbctl_fbd_rd_en_c2; output	[2:0]	fbctl_fbd_rd_entry_c2; output	[1:0]	dram_sctag_chunk_id_r1; output		dram_sctag_data_vld_r1; output	[2:0]	fbctl_fbd_wr_entry_r1 ;

output	[2:0]	sctag_dram_rd_req_id ;

output		fb_count_eq_0; output		fbctl_mbctl_entry_avail ; output		fbctl_mbctl_match_c2; output	[2:0]	fbctl_mbctl_fbid_d2;
output	[3:0]	fbf_enc_ld_mbid_r1;
output		fbf_ready_miss_r1;
output	[3:0]	fbf_enc_dep_mbid_c4;
output		fbf_st_or_dep_rdy_c4;
output	fbctl_mbctl_nofill_d2; output	fbctl_mbctl_stinst_match_c2; 
output		scdata_fb_hit_c3; 
output		fbctl_vuad_bypassed_c3;


output		fbctl_arb_l2rd_en; output	[3:0]	fbctl_arbdp_way_px2; output		fbctl_arbdp_tecc_px2;
output	[2:0]	fbctl_arbdp_entry_px2;
output		fbctl_arbctl_vld_px1; 
output	fbctl_corr_err_c8 ; output	fbctl_uncorr_err_c8 ; output	dram_scb_mecc_err_d1, dram_scb_secc_err_d1;

output	fbctl_spc_corr_err_c7; output	fbctl_spc_uncorr_err_c7; output	fbctl_spc_rd_vld_c7; output	fbctl_bsc_corr_err_c12; output	fbctl_ld64_fb_hit_c12; 
output	fbctl_dis_cerr_c3;
output	fbctl_dis_uerr_c3; 


input		mbctl_fbctl_next_vld_c4;
input	[3:0]	mbctl_fbctl_next_link_c4;
input		mbf_delete_c4;
input		mbctl_hit_c4;
input		mbf_insert_c4;
input	[3:0]	mbdata_fbctl_mbf_entry;
input		mbctl_fbctl_dram_pick;
input   [2:0]   mbctl_fbctl_fbid;
input   [3:0]   mbctl_fbctl_way ;
input           mbctl_fbctl_way_fbid_vld ;
input	[3:0]	mbf_insert_mbid_c4;

input	[4:0]	mbdata_fbctl_rqtyp_d1; input		mbdata_fbctl_rsvd_d1; 
input		decdp_imiss_inst_c2;
input	[2:0]	arbdp_inst_mb_entry_c1;
input		decdp_cas1_inst_c2;

input	arbdp_rdma_inst_c1;  input	mbctl_rdma_reg_vld_c2; 
input	decc_scrd_uncorr_err_c8;
input	decc_scrd_corr_err_c8;
input	decc_bscd_corr_err_c8;
input	decc_bscd_uncorr_err_c8;

input	tag_error_c8; 
input	tagctl_rd64_complete_c11; input	cerr_ack_tmp_c4, uerr_ack_tmp_c4 ; input	spc_rd_cond_c3; 

input	csr_fbctl_scrub_ready ;

input		arbctl_fbctl_fbsel_c1; input		arbctl_fill_vld_c2;
input		arbctl_fbctl_hit_off_c1; input		arbctl_fbctl_inst_vld_c2;
input		decdp_wr8_inst_c2;

input		arbdp_inst_mb_c2 ;
input		decdp_ld64_inst_c2;


input	[7:0] 	fb_cam_match;

input	      l2_bypass_mode_on ;
input	      l2_dir_map_on ; 
input		dram_sctag_data_vld_r0; input	[2:0]	dram_sctag_rd_req_id_r0 ; input	[1:0]	dram_sctag_chunk_id_r0;  input	dram_sctag_secc_err_r2;
input	dram_sctag_mecc_err_r2;
input	dram_sctag_scb_mecc_err;
input	dram_sctag_scb_secc_err;


input	tagctl_rdma_gate_off_c2;

input	arst_l, grst_l, dbginit_l ;
input	si, se;
input	rclk;








wire	  ;
wire	[7:0]	fb_wr_ptr_d1;
wire	[2:0]	enc_wr_ptr_d1;

// fb control bits.
wire	[7:0]	fb_set_valid, fb_valid_prev , fb_valid ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb  ;
wire	[7:0]	;
wire	[2:0]	enc_wr_ptr_d1;

// fb control bits.
wire	[7:0]	fb_set_valid, fb_valid_prev , fb_valid ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[2:0]	;

// fb control bits.
wire	[7:0]	fb_set_valid, fb_valid_prev , fb_valid ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;

wire	[7:0]	, fb_valid_prev , fb_valid ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb,  , fb_valid ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb ,  ;
wire	[7:0]	fb_stinst;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb ;
wire	[7:0]	;
wire	[7:0]	fb_nofill;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	;
wire	[7:0]	fb_l2_ready_in,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	,	fb_l2_ready;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb,	;
wire	[7:0]	fb_bypassed_in, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	, fb_bypassed ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb,  ;
wire	[3:0]	way0, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb ;
wire	[3:0]	, way1, way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , way2, way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , way3;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[3:0]	way4, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[3:0]	, way5, way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , way6, way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , way7;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[7:0]	fb_way_vld_in, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	, fb_way_vld;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[3:0]	mbid0, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[3:0]	, mbid1, mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , mbid2, mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , mbid3;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[3:0]	mbid4, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[3:0]	, mbid5, mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , mbid6, mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , mbid7;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[7:0]	fb_next_link_vld_in, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	, fb_next_link_vld;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[7:0]	fb_cerr, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	, fb_uerr ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb,  ;
wire	fb_cerr_pend;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb ;
wire	;
wire	fb_uerr_pend;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	;
wire	fb_tecc_pend;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	;




wire	[7:0]	fill_entry_num_c3, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;




wire	[7:0]	, fill_complete_c3, fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , fill_complete_c4;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire		fill_vld_c3  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire		  ;
wire	fb_count_en, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb  ;
wire	, fb_count_rst;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, ;
wire	[3:0]	fb_count_prev, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[3:0]	, fb_count_plus1, fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb, , fb_count_minus1 ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb,  ;
wire	[3:0]	fb_count;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb ;
wire	[3:0]	;

wire	[4:0]	mbf_rqtyp_d2;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;

wire	[4:0]	;
wire	[7:0]	fb_set_valid_d2;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire	[7:0]	;
wire		fb_stinst_d2;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;
wire		;

wire		l2_bypass_mode_on_d1 ;
wire  [2:0]   mbctl_fb;

wire		 ;
wire  [2:0]   mbctl_fb ;
wire  [2:0]   ;
wire  [3:0]   mbctl_fbctl_way_d1 ;
wire          mbctl_fbctl_way_vld_d1 ;
wire  [7:0]   dec_mb_fb_id_d1;

wire	[7:0]	fb_hit_vec_c2 ;
wire	imiss_ld64_fb_hit_c2, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire  [3:0]    ;
wire          mbctl_fbctl_way_vld_d1 ;
wire  [7:0]   dec_mb_fb_id_d1;

wire	[7:0]	fb_hit_vec_c2 ;
wire	imiss_ld64_fb_hit_c2, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire           ;
wire  [7:0]   dec_mb_fb_id_d1;

wire	[7:0]	fb_hit_vec_c2 ;
wire	imiss_ld64_fb_hit_c2, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire  [7:0]   ;

wire	[7:0]	fb_hit_vec_c2 ;
wire	imiss_ld64_fb_hit_c2, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[7:0]	 ;
wire	imiss_ld64_fb_hit_c2, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, imiss_ld64_fb_hit_c3 ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	[1:0]	dram_return_cnt, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	[1:0]	, dram_return_cnt_plus1 ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	dram_cnt_reset;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	;
wire	dram_data_vld_r1;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	[2:0]	dram_rd_req_id_r1;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[2:0]	;
wire	cas1_inst_c3, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, cas1_inst_c4;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	dram_count_state0, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, dram_count_state2 ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	fb_hit_vec_c3, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	, fb_hit_vec_c4 ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	dec_rdreq_id_r0_d1;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	;

wire	dep_ptr_wr_en_c4, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	, non_dep_mbf_insert_c4;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[7:0]	dep_wr_ptr_c4, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[7:0]	, non_dep_wr_ptr_c4;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[3:0]	mbf_entry_d2;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[3:0]	;
wire	[7:0]	sel_def_mbid;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[7:0]	;


wire	[3:0]	mbid0_in, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;


wire	[3:0]	, mbid1_in, mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , mbid2_in, mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , mbid3_in;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[3:0]	mbid4_in, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[3:0]	, mbid5_in, mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , mbid6_in, mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , mbid7_in;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;

wire	[7:0]	fb_l2_rd_ptr_in;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[7:0]	;
wire	[7:0]	fb_l2_rd_ptr;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[7:0]	;

wire	[3:0]	mux1_mbid_r1, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[3:0]	, mux2_mbid_r1 ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[3:0]	mux1_dep_mbid_c4, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[3:0]	, mux2_dep_mbid_c4 ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	ready_ld_r0_d1 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	 ;
wire	fill_entry_0to3_c4 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	 ;
wire	[7:0]	fill_entry_num_c1, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	, fill_entry_num_c2 ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	pick_s0, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	, pick_s1, pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s2, pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s3 ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	pick_s0_quad0, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, pick_s1_quad0, pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s2_quad0, pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s3_quad0 ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	pick_s0_quad1, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, pick_s1_quad1, pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s2_quad1, pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , pick_s3_quad1 ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	pick_quad_s0, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, pick_quad_s1 ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	[3:0]	pick_quad0_in, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	[3:0]	, pick_quad1_in ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[1:0]	pick_quad_in ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[1:0]	 ;
wire	[3:0]	pick_quad0_sel, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[3:0]	, pick_quad1_sel ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[1:0]	pick_quad_sel;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[1:0]	;

wire	[7:0]	l2_pick_vec;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[7:0]	;
wire		l2_pick, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		, l2_pick_d1 ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire		l2_wait_in, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire		, l2_wait;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;

wire	init_pick_state;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	;
wire	sel_l2st_lshift, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, sel_l2st_same; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ; 
wire	[3:0]	l2_rd_state_lshift, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w; 
wire	[3:0]	, l2_rd_state_in, l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , l2_rd_state ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	sel_l2st_lshift_quad0, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	, sel_l2st_same_quad0;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[3:0]	l2_rd_state_lshift_quad0, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[3:0]	, l2_rd_state_in_quad0, l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , l2_rd_state_quad0 ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	sel_l2st_lshift_quad1, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	, sel_l2st_same_quad1;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[3:0]	l2_rd_state_lshift_quad1, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[3:0]	, l2_rd_state_in_quad1, l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , l2_rd_state_quad1 ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	[2:0]	enc_l2_rd_ptr ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	[2:0]	 ;
wire	[3:0]	mux1_way, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[3:0]	, mux2_way, fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , fill_way ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire		sctag_scdata_fb_hit_c2; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire		; // used in C5 to select between
wire	sel_c2_entry;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w; wire	;
wire	[2:0]	fb_rd_entry_c2;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[2:0]	;
wire	[2:0]	enc_hit_vec_c2, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[2:0]	, enc_hit_vec_c3 ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[2:0]	fill_entry_c2;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[2:0]	;

wire		mecc_err_r3, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire		, secc_err_r3;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire		fbctl_corr_err_c3, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		, fbctl_corr_err_c4, fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , fbctl_corr_err_c5;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire		fbctl_corr_err_c6, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		, fbctl_corr_err_c7 ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire		fbctl_uncorr_err_c3, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire		, fbctl_uncorr_err_c4, fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , fbctl_uncorr_err_c5;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire		fbctl_uncorr_err_c6, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		, fbctl_uncorr_err_c7 ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire		dram_data_vld_r2, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire		, dram_data_vld_r3 ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[2:0]	dram_rd_req_id_r2, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[2:0]	, dram_rd_req_id_r3 ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	fb_cerr_in, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	, fb_uerr_in ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	fb_cerr_prev, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	, fb_uerr_prev ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	fbctl_hit_c3;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	;
wire	spc_rd_vld_c3;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	spc_rd_vld_c4, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, spc_rd_vld_c5 ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	spc_rd_vld_c6, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, spc_rd_vld_c7 ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	clear_err_c3;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	;
wire	spc_corr_err_c3, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, spc_corr_err_c4, spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , spc_corr_err_c5;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	spc_corr_err_c6, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, spc_corr_err_c7 ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	spc_uncorr_err_c3, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, spc_uncorr_err_c4, spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , spc_uncorr_err_c5;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	spc_uncorr_err_c6, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, spc_uncorr_err_c7 ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	fb_uerr_pend_set, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, fb_uerr_pend_reset, fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , fb_uerr_pend_in ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	fb_cerr_pend_set, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, fb_cerr_pend_reset, fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , fb_cerr_pend_in ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	fb_tecc_pend_set, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, fb_tecc_pend_reset;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	fb_tecc_pend_in;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;

wire	fbctl_hit_c2;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	;
wire	fb_nofill_d2;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;

wire	[7:0]	no_fill_entry_dequeue_c3; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[7:0]	; 
wire		en_dequeue_c3;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w; 
wire		;
wire		en_hit_dequeue_c2;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		;
wire		ready_ld64_r0_d1;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		;
wire		mbf_rsvd_d2;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		;
wire	fb_nofill_rst;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	qual_hit_vec_c2, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, qual_hit_vec_c3, qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, , qual_hit_vec_c4;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;

wire	[7:0]	dep_wr_qual_c4;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[7:0]	;

wire	[2:0]	fill_entry_c3;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[2:0]	;
wire	sel_c2_fill_entry;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	sel_c3_fill_entry;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	sel_def_hit_entry_mux1;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	l2_dir_map_on_d1;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;
wire	dram_data_vld_r0_d1;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	;

wire	[1:0]	dram_sctag_chunk_id_r0_d1;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

wire	[1:0]	;
wire	[2:0]	dram_rd_req_id_r0_d1;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[2:0]	;
wire	fbhit_cerr_err_c3, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, fbhit_uerr_err_c3 ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	bsc_corr_err_c3, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, ld64_fb_hit_c3;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	wr8_inst_c3, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, wr8_inst_c4;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire            dbb_rst_l;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire            ;
wire	[7:0]	dec_fill_entry_c3;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[7:0]	;
wire		cerr_ack_c4, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire		, uerr_ack_c4 ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	inst_vld_c3;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	;
wire	fbcerr0_d1, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, fbuerr0_d1;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;


wire	[7:0]	fill_complete_sel ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;


wire	[7:0]	 ;
wire	fill_complete_4to7_def, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, fill_complete_0to3_def ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	[7:0]	fb_l2_rd_ptr_sel;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	[7:0]	;
wire	way_mux1_def, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	, way_mux2_def ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;
wire	rdreq_0to3_def, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
wire	, rdreq_4to7_def ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w,  ;

wire	[7:0]	dep_wr_ptr_c4_rst, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;

wire	[7:0]	, non_dep_wr_ptr_c4_rst;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w, ;
wire	[7:0]	fb_set_valid_d2_rst;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire	[7:0]	;
wire 	fb_tecc_pend_d1;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;
wire 	;
////////////////////////////////////////////////////////////////////////////////
// L2 OFF MODE :
//
// The RTL for fbctl contains the following exceptions to handle off mode operation.
//
// 1) A non Store, non LD64 entry is invalidated in C2 on a Fill Buffer hit.
//    stores have to be kept around to write to DRAM, LD64s turn the valid bit
//    of in C3( they can afford to do so due to the access bubbles following a ld64).
//
// 2) Fill Buffer is one deep only 
//
// 3) fb_l2_ready is set only in the following  case, 
//	 A non CAS1 instruction hitting an entry with fb_stinst =1 .
//
// 4) Fill does not wake up stores by default. It only wakes up
//    dependent instructions in the Miss Buffer.
// 
// 5) dep wr enable is asserted only if an instruction( other than a CAS1) hits
//    a Fill Buffer entry with fb_stinst=1.
//
// 6) Fill Pipeline is skewed by one cycle.
//
// 7)  In l2_bypass_mode, the way_vld bit is not required to be set.
//	for an l2_pick
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// L2 DIR MAP MODE ON
//
//  This mode is different from the regular mode of operation in the following
// ways
// - Loads/Imisses are not readied by the second incoming packet of data from the 
//   dram. Check the expression for ready_miss_r1
// - Loads/Imisses are readied similar to stores, i.e. after a Fill.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
 // Reset flop
 ///////////////////////////////////////////////////////////////////

 dffrl_async    #(1)    reset_flop      (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w;

  
 dffrl_async    #(1)          (.q(dbb_rst_l),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w      (.q(),
                                        .clk(rclk),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w),
                                        .clk(),
                                        .rst_l(arst_l),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w),
                                        .rst_l(),
                                        .din(grst_l),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w),
                                        .din(),
                                        .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w),
                                        .se(), .si(), .so());


////////////////////////////////////////////////////////////////////////////////
// Fill Buffer Insertion Pipeline.
// The Fill Buffer (FB) is inserted when a Miss Buffer is read for making
// a request to DRAM. The following pipeline is used for FB insertion
//
//------------------------------------------------------------------------------
//	D0			D1				D2
//------------------------------------------------------------------------------
//	dram pick (mbctl)	read mbtag			write fbtag+ecc
//
//				read mbdata
//				for rqtyp and tag ecc		write "stinst" 
//								write insert mbid
//		
//	xmit dram pick		generate wr ptr			fb_entry_avail 
//	to fbctl.		xmit to fbtag.			logic
//
//				xmit dram_pickd1		xmit inserting
//				as wen to fbtag.		fbid to mbf
//								
//				set valid bit			xmit addr(arbaddrdp)
//								xmit req id (fbctl)
//				update fbcount			xmit req ( mbctl).
//
//								
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

//////////////////
// 1.  Generation of insertion ptr
// and wen for fbtag.
//////////////////
dff_s   #(1)  ff_dram_pick_d1    (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w), .si(), .so());



dff_s   #(1)      (.din(mbctl_fbctl_dram_pick), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w    (.din(), .clk(rclk),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w), .clk(),
                         .q(dram_pick_d1), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w),
                         .q(), .se(se), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w), .se(), .si(), .so());

assign	fb_wr_ptr_d1[0] = ~fb_valid[0] ;
assign	fb_wr_ptr_d1[1] = fb_valid[0] & ~fb_valid[1];
assign	fb_wr_ptr_d1[2] = &(fb_valid[1:0]) & ~fb_valid[2] ;
assign	fb_wr_ptr_d1[3] = &(fb_valid[2:0]) & ~fb_valid[3] ;
assign	fb_wr_ptr_d1[4] = &(fb_valid[3:0]) & ~fb_valid[4] ;
assign	fb_wr_ptr_d1[5] = &(fb_valid[4:0]) & ~fb_valid[5] ;
assign	fb_wr_ptr_d1[6] = &(fb_valid[5:0]) & ~fb_valid[6] ;
assign	fb_wr_ptr_d1[7] = &(fb_valid[6:0]) & ~fb_valid[7] ;

assign	fbctl_fbtag_wr_ptr = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w), .si(), .so());

assign	[0] = ~[0] ;
assign	[1] = [0] & ~[1];
assign	[2] = &([1:0]) & ~[2] ;
assign	[3] = &([2:0]) & ~[3] ;
assign	[4] = &([3:0]) & ~[4] ;
assign	[5] = &([4:0]) & ~[5] ;
assign	[6] = &([5:0]) & ~[6] ;
assign	[7] = &([6:0]) & ~[7] ;

assign	 = fb_wr_ptr_d1 ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w =  ;
assign	fbctl_fbtag_wr_en = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;
assign	 = dram_pick_d1 ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w =  ;

//////////////////
// 2.  xmit fbid to mbf
// for mbctl tracking.THe fbid is later
// re-transmitted to fbctl for writing the way
// and way valid fields in fbctl.
//////////////////

assign	enc_wr_ptr_d1[0] = fb_wr_ptr_d1[1] | fb_wr_ptr_d1[3] | 
	   fb_wr_ptr_d1[5] | fb_wr_ptr_d1[7]  ;
assign	enc_wr_ptr_d1[1] = fb_wr_ptr_d1[2] | fb_wr_ptr_d1[3] |
	   fb_wr_ptr_d1[6] | fb_w ;


assign	[0] = [1] | [3] | 
	   [5] | [7]  ;
assign	[1] = [2] | [3] |
	   [6] | [7]  ;
assign	[2] = [4] | [5] |
   	   [6] | [7]  ;

dff_s   #(3)      (.din(enc_wr_ptr_d1[2:0]), .clk(rclk),
                  .q(fbctl_mbctl_fbid_d2[2:0]), .se(se), .si(), .so());

///////////////////////////////////////////////////////////////
// 3.The sctag-dram interface for read requests consists of
// req, req_id and addr signals all of which are 
// transmitted in the D2 stage
///////////////////////////////////////////////////////////////

assign	sctag_dram_rd_req_id = fbctl_mbctl_fbid_d2 ;


//////////////////////////////////////////////////////////
// VALID bit logic.
// The Valid bit is set in cycle D1 of a miss insertion.
// It is reset in the C3 cycle of a FIll. Since a Fill is
// followed by 3 bubbles, the earliest operation following
// a Fill will be in C1 when the fill is in C4. This means that
// an operation following the fill ( to the same $ line)
// will never hit the FB.
//
// Valid bit is also reset for a nofill entry if that entry
// encounters a hit. Since ld64s are the only instructions that
// will cause a no_fill entry, the reset operation can be
// performed in C3 like that for a Fill operation. This is 
// because a ld64 is followed by two bubbles.
//
// Valid bit is reset for a fb hit to entry 0 in l2 off mode
// if that entry has fb_stinst==0. In this case, the valid bit
// will have to be reset in C2 since the following instruction
// will have to see the effects of it.Hence this reset condition
// is the most critical.
//////////////////////////////////////////////////////////

dff_s   #(1)  ff_fill_vld_c3    (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din([2:0]), .clk(),
                  .q(fbctl_mbctl_fbid_d2[2:0]), .se(se), .si(), .so());

///////////////////////////////////////////////////////////////
// 3.The sctag-dram interface for read requests consists of
// req, req_id and addr signals all of which are 
// transmitted in the D2 stage
///////////////////////////////////////////////////////////////

assign	sctag_dram_rd_req_id = fbctl_mbctl_fbid_d2 ;


//////////////////////////////////////////////////////////
// VALID bit logic.
// The Valid bit is set in cycle D1 of a miss insertion.
// It is reset in the C3 cycle of a FIll. Since a Fill is
// followed by 3 bubbles, the earliest operation following
// a Fill will be in C1 when the fill is in C4. This means that
// an operation following the fill ( to the same $ line)
// will never hit the FB.
//
// Valid bit is also reset for a nofill entry if that entry
// encounters a hit. Since ld64s are the only instructions that
// will cause a no_fill entry, the reset operation can be
// performed in C3 like that for a Fill operation. This is 
// because a ld64 is followed by two bubbles.
//
// Valid bit is reset for a fb hit to entry 0 in l2 off mode
// if that entry has fb_stinst==0. In this case, the valid bit
// will have to be reset in C2 since the following instruction
// will have to see the effects of it.Hence this reset condition
// is the most critical.
//////////////////////////////////////////////////////////

dff_s   #(1)  ff_fill_vld_c3    (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
                  .q([2:0]), .se(), .si(), .so());

///////////////////////////////////////////////////////////////
// 3.The sctag-dram interface for read requests consists of
// req, req_id and addr signals all of which are 
// transmitted in the D2 stage
///////////////////////////////////////////////////////////////

assign	sctag_dram_rd_req_id = fbctl_mbctl_fbid_d2 ;


//////////////////////////////////////////////////////////
// VALID bit logic.
// The Valid bit is set in cycle D1 of a miss insertion.
// It is reset in the C3 cycle of a FIll. Since a Fill is
// followed by 3 bubbles, the earliest operation following
// a Fill will be in C1 when the fill is in C4. This means that
// an operation following the fill ( to the same $ line)
// will never hit the FB.
//
// Valid bit is also reset for a nofill entry if that entry
// encounters a hit. Since ld64s are the only instructions that
// will cause a no_fill entry, the reset operation can be
// performed in C3 like that for a Fill operation. This is 
// because a ld64 is followed by two bubbles.
//
// Valid bit is reset for a fb hit to entry 0 in l2 off mode
// if that entry has fb_stinst==0. In this case, the valid bit
// will have to be reset in C2 since the following instruction
// will have to see the effects of it.Hence this reset condition
// is the most critical.
//////////////////////////////////////////////////////////

dff_s   #(1)  ff_fill_vld_c3    (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());


assign	 = fbctl_mbctl_fbid_d2 ;


//////////////////////////////////////////////////////////
// VALID bit logic.
// The Valid bit is set in cycle D1 of a miss insertion.
// It is reset in the C3 cycle of a FIll. Since a Fill is
// followed by 3 bubbles, the earliest operation following
// a Fill will be in C1 when the fill is in C4. This means that
// an operation following the fill ( to the same $ line)
// will never hit the FB.
//
// Valid bit is also reset for a nofill entry if that entry
// encounters a hit. Since ld64s are the only instructions that
// will cause a no_fill entry, the reset operation can be
// performed in C3 like that for a Fill operation. This is 
// because a ld64 is followed by two bubbles.
//
// Valid bit is reset for a fb hit to entry 0 in l2 off mode
// if that entry has fb_stinst==0. In this case, the valid bit
// will have to be reset in C2 since the following instruction
// will have to see the effects of it.Hence this reset condition
// is the most critical.
//////////////////////////////////////////////////////////

dff_s   #(1)  ff_fill_vld_c3    (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 =  ;


//////////////////////////////////////////////////////////
// VALID bit logic.
// The Valid bit is set in cycle D1 of a miss insertion.
// It is reset in the C3 cycle of a FIll. Since a Fill is
// followed by 3 bubbles, the earliest operation following
// a Fill will be in C1 when the fill is in C4. This means that
// an operation following the fill ( to the same $ line)
// will never hit the FB.
//
// Valid bit is also reset for a nofill entry if that entry
// encounters a hit. Since ld64s are the only instructions that
// will cause a no_fill entry, the reset operation can be
// performed in C3 like that for a Fill operation. This is 
// because a ld64 is followed by two bubbles.
//
// Valid bit is reset for a fb hit to entry 0 in l2 off mode
// if that entry has fb_stinst==0. In this case, the valid bit
// will have to be reset in C2 since the following instruction
// will have to see the effects of it.Hence this reset condition
// is the most critical.
//////////////////////////////////////////////////////////

dff_s   #(1)  ff_fill_vld_c3    (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ;



dff_s   #(1)      (.din(arbctl_fill_vld_c2), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din(), .clk(rclk),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .clk(),
                .q(fill_vld_c3), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
                .q(), .se(se), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .se(), .si(), .so()); 


assign	no_fill_entry_dequeue_c3 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so()); 


assign	 =  (fb_hit_vec_c3 & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 =  ( & fb_nofill  & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 &   & 
				{8{qual_hit_vec_c3}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
  & 
				{8{}});

// In l2 off mode, any non-store entry is dequeued 
// when an inst hits  the Fill Buffer.

dff_s   #(1)  ff_l2_bypass_mode_on    (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
}});


dff_s   #(1)      (.din(l2_bypass_mode_on), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din(), .clk(rclk),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .clk(),
                    .q(l2_bypass_mode_on_d1), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
                    .q(), .se(se), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .se(), .si(), .so());

dff_s   #(1)  ff_l2_dir_map_on_d1    (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());

dff_s   #(1)      (.din(l2_dir_map_on), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din(), .clk(rclk),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .clk(),
                    .q(l2_dir_map_on_d1), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
                    .q(), .se(se), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .se(), .si(), .so());

// In OFF mode, an instruction(B) may be in C1 when
// a C2 instruction(A) hits the Fill Buffer. Hence the valid bit
// reset condition should be flopped to C3 so that instruction B
// can see the effects of instruction A on the Fill Buffer.
// However, en_hit_dequeue_c2 had a critical component, rdma_gate_off_c2
// This component has been removed and replaced with
// rdma_inst_c2 & mbctl_rdma_reg_vld_c2.


dff_s   #(1)  ff_rdma_inst_c2    (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());



dff_s   #(1)      (.din(arbdp_rdma_inst_c1), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din(), .clk(rclk),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .clk(),
               .q(rdma_inst_c2), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
               .q(), .se(se), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .se(), .si(), .so());

assign	en_hit_dequeue_c2 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());

assign	 = arbdp_inst_mb_c2  &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 =   &
                                arbctl_fbctl_inst_vld_c2 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
  &
                                 &
				~(rdma_inst_c2 & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 &
				~( & mbctl_rdma_reg_vld_c2) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 & ) &
				fb_hit_vec_c2[0] & 
				~fb_stinst[0] & // not a store
				 ~fb_nofill[0] & // not a  ld64
				l2_bypass_mode_on_d1 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
) &
				[0] & 
				~[0] & 				 ~[0] & 				 ; // OFF mode on.

assign	dec_fill_entry_c3[7:1] = fill_entry_num_c3[7:1] & {7{fill_vld_c3}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ; 
assign	[7:1] = [7:1] & {7{}} ;

assign	fill_complete_c3[7:1] = dec_fill_entry_c3[7:1] |
				no_fill_entry_dequeue_c3[7:1] ;

assign	dec_fill_entry_c3[0] = fill_entry_num_c3[0] & fill_vld_c3 ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
}} ;

assign	[7:1] = [7:1] |
				[7:1] ;

assign	[0] = [0] &  ;

assign  fill_complete_c3[0] = 	dec_fill_entry_c3[0] | 
				no_fill_entry_dequeue_c3[0] |
				en_hit_dequeue_c2 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ;

assign  [0] = 	[0] | 
				[0] |
				 ; // off mode condition only.

// COVERAGE: exercise all fill_complete_c3[7:0] conditions. 
// especially all en_hit_dequeue_c2 conditions.

assign	fb_set_valid = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ; 

assign	 = fb_wr_ptr_d1  
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 =   
			& {8{dram_pick_d1}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
  
			& {8{}} ;

dff_s   #(8)  ff_fb_set_valid_d2    (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
}} ;

dff_s   #(8)      (.din(fb_set_valid[7:0]), .clk(rclk),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din([7:0]), .clk(),
		.q(fb_set_valid_d2[7:0]), .se(se), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
		.q([7:0]), .se(), .si(), .so());

assign	fb_valid_prev = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());

assign	 = ( fb_set_valid_d2 | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (  | fb_valid )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 |  )   &
			~fill_complete_c3;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 )   &
			~;

dffrl_s   #(8)  ff_valid_bit    (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
;

dffrl_s   #(8)      (.din(fb_valid_prev[7:0]), .clk(rclk), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din([7:0]), .clk(), 
	.rst_l(dbb_rst_l), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), 
	.rst_l(), .q(fb_valid[7:0]), .se(se), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .q([7:0]), .se(), .si(), .so());

//////////////////////////////////////////////////////////
// FB Counter 
// Increment and decrement conditions are the same as
// set and reset conditions of the valid bit, respectively.
// 
// fb_count_eq_0 is required by mbctl to ready a csr write.
//
// fbctl_mbctl_entry_avail is required by mbctl as a condition
// for dram_pick.
//////////////////////////////////////////////////////////

assign	en_dequeue_c3 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());


assign	 = (|( no_fill_entry_dequeue_c3 )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (|(  )) |
				fill_vld_c3   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 )) |
				   |
				en_hit_dequeue_c2 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
   |
				 ;


assign  fb_count_en = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ;


assign   = ( dram_pick_d1 | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (  | en_dequeue_c3 ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 |  ) & 
			~( dram_pick_d1 & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ) & 
			~(  & en_dequeue_c3 )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 &  )  ;

assign  fb_count_plus1  = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 )  ;

assign    = fb_count + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
  =  + 4'b1 ;
assign  fb_count_minus1 = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 + 4bb ;
assign   = fb_count - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 =  - 4'b1 ;

assign	fb_count_rst = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 - 4bb ;

assign	 = (~dbb_rst_l );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (~ );

mux2ds  #(4) mux_fb_count  (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 );

mux2ds  #(4)   (.dout (fb_count_prev[3:0]),
          	.in0(fb_count_plus1[3:0]), .in1(fb_count_minus1[3:0]),
                .sel0(dram_pick_d1), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
  (.dout ([3:0]),
          	.in0([3:0]), .in1([3:0]),
                .sel0(), .sel1(~dram_pick_d1));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .sel1(~));

dffre_s   #(4)  ff_fb_count   (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
));

dffre_s   #(4)     (.din(fb_count_prev[3:0]), 
	  .clk(rclk), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
   (.din([3:0]), 
	  .clk(), .rst(fb_count_rst),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .rst(),.en(fb_count_en),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),.en(),
         .q(fb_count[3:0]), .se(se), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
         .q([3:0]), .se(), .si(), .so()); 

assign	fb_count_eq_0 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so()); 

assign	 = ( fb_count == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (  == 4'b0 ) ;

///////////////////////////////////////////
// in L2 off mode, Fb is only one deep.
///////////////////////////////////////////


assign	fbctl_mbctl_entry_avail = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 == 4bb ) ;



assign	 = 
	( ~fb_count[3] & ~l2_bypass_mode_on_d1 )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = 
	( ~[3] & ~ )  |
	( fb_count_eq_0 & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 )  |
	(  & l2_bypass_mode_on_d1 ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 &  ) ;



//////////////////////////////////////////////////////////
// STINST: Set for any miss that requires a fill to happen  
//	  before it is processed out of the Miss Buffer.
//
//	   Lds , Imisses and Strloads are the only requests which bypass
//	   data out of the fill buffer. All other instructions
//	   will wait for a FIll to happen before they are readied
//	   in the mIss Buffer.
//
//	   This bit is not valid unless fb_valid is set.
//////////////////////////////////////////////////////////

dff_s   #(5)  ff_rqtyp_d2    (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ) ;




dff_s   #(5)      (.din(mbdata_fbctl_rqtyp_d1[4:0]), .clk(rclk),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din([4:0]), .clk(),
			.q(mbf_rqtyp_d2[4:0]), .se(se), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
			.q([4:0]), .se(), .si(), .so());

dff_s   #(1)  ff_snp_d2    (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());

dff_s   #(1)      (.din(mbdata_fbctl_rsvd_d1), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
    (.din(), .clk(rclk),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .clk(),
			.q(mbf_rsvd_d2), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
),
			.q(), .se(se), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .se(), .si(), .so());


assign	fb_stinst_d2 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
), .si(), .so());


assign	 = (~( mbf_rqtyp_d2 == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 = (~(  == `IMISS_RQ ) & 
			~( mbf_rqtyp_d2 == `LOAD_RQ )  & 
			~( mbf_rqtyp_d2 == `STRLOAD_RQ )  & 
			~( mbf_rsvd_d2 & mbf_rqtyp_d2[0] ) ) ;

dffe_s   #(1)  ff_stinst_0    (.din(fb_stinst_d2), .en(fb_set_valid_d2[0]),
		.clk(rclk), .q(fb_stinst[0]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_1    (.din(fb_stinst_d2), .en(fb_set_valid_d2[1]),
		.clk(rclk), .q(fb_stinst[1]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_2    (.din(fb_stinst_d2), .en(fb_set_valid_d2[2]),
		.clk(rclk), .q(fb_stinst[2]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_3    (.din(fb_stinst_d2), .en(fb_set_valid_d2[3]),
		.clk(rclk), .q(fb_stinst[3]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_4    (.din(fb_stinst_d2), .en(fb_set_valid_d2[4]),
		.clk(rclk), .q(fb_stinst[4]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_5    (.din(fb_stinst_d2), .en(fb_set_valid_d2[5]),
		.clk(rclk), .q(fb_stinst[5]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_6    (.din(fb_stinst_d2), .en(fb_set_valid_d2[6]),
		.clk(rclk), .q(fb_stinst[6]), .se(se), .si(), .so());
dffe_s   #(1)  ff_stinst_7    (.din(fb_stinst_d2), .en(fb_set_valid_d2[7]),
		.clk(rclk), .q(fb_stinst[7]), .se(se), .si(), .so());


//////////////////////////////////////////////////////////
// NO_FILL: Set or reset when an entry is written into
// 	    the fbtags. 
//	    Set for a ld64 instruction and reset for any
//	    other instruction.
//	    Used in the valid bit setting and l2_ready logic.
//
// fbctl_mbctl_nofill_d2 is used to not turn on fbid_vld in 
// the miss buffer.
//////////////////////////////////////////////////////////



assign	fb_nofill_d2 = mbf_rsvd_d2 & mbf_rqtyp_d2[0] ;
assign	fbctl_mbctl_nofill_d2 = fb_nofill_d2 ;
assign	fb_nofill_rst = ~dbb_rst_l;

dffre_s   #(1)  ff_nofill_0    (.din(fb_nofill_d2), .en(fb_set_valid_d2[0]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[0]), .se(se), .si(), .so());
dffre_s   #(1)  ff_nofill_1    (.din(fb_nofill_d2), .en(fb_set_valid_d2[1]),
		.rst(fb_nofill_rst),
        	.clk(rclk), .q(fb_nofill[1]), .se(se), .si(), .so());
 ==  )