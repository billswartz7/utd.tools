
	 					

 

 

module tlu_mmu_dp ( 
      tlu_dtsb_split_w2, tlu_dtsb_size_w2, tlu_dtag_access_w2,
   tlu_itsb_split_w2, tlu_itsb_size_w2,
   tlu_itlb_tte_tag_w2, tlu_itlb_tte_data_w2, tlu_dtlb_tte_tag_w2, 
   tlu_dtlb_tte_data_w2, tlu_idtlb_dmp_key_g, tlu_dsfsr_flt_vld, 
   tlu_isfsr_flt_vld, mra_wdata, tlu_ctxt_cfg_w2, tlu_tag_access_ctxt_g, 
   lsu_exu_ldxa_data_g, so, tlu_tsb_base_w2_d1,
      tlu_addr_msk_g, dmmu_any_sfsr_wr, dmmu_sfsr_wr_en_l, dmmu_sfar_wr_en_l, 
   immu_any_sfsr_wr, immu_sfsr_wr_en_l, tlu_lng_ltncy_en_l,
   lsu_tlu_dside_ctxt_m, lsu_tlu_pctxt_m, tlu_tag_access_ctxt_sel_m, 
   lsu_tlu_st_rs3_data_b63t59_g, lsu_tlu_st_rs3_data_b47t0_g,
   exu_lsu_ldst_va_e, tlu_idtsb_8k_ptr,lsu_tlu_tlb_dmp_va_m, ifu_tlu_pc_m, 
   tlu_slxa_thrd_sel, 
   tlu_tte_tag_g, tlu_dmp_key_vld_g, tlb_access_rst_l, 
   tag_access_wdata_sel, mra_rdata, tlu_admp_key_sel, 
   tlu_isfsr_din_g, tlu_dsfsr_din_g, 
   tlu_tte_wr_pid_g, tlu_tte_real_g, tlu_ldxa_l1mx1_sel, 
   tlu_ldxa_l1mx2_sel, tlu_ldxa_l2mx1_sel, rclk, grst_l, arst_l,
   tlu_tlb_tag_invrt_parity, tlu_tlb_data_invrt_parity, tlu_sun4r_tte_g,
   tlu_tsb_rd_ps0_sel, si, se, tlu_tlb_access_en_l_d1
   ) ;	



input			tlu_addr_msk_g ;	input			dmmu_any_sfsr_wr ; 
input	[3:0]		dmmu_sfsr_wr_en_l ; 
input	[3:0]		dmmu_sfar_wr_en_l ; 
input                   immu_any_sfsr_wr ;
input   [3:0]           immu_sfsr_wr_en_l ;
input  	[12:0]          lsu_tlu_dside_ctxt_m ;
input  	[12:0]          lsu_tlu_pctxt_m ;
input	[2:0]		tlu_tag_access_ctxt_sel_m ;	
input	[63:59]		lsu_tlu_st_rs3_data_b63t59_g ;
input	[47:0]		lsu_tlu_st_rs3_data_b47t0_g ;
input	[47:0]		exu_lsu_ldst_va_e ;
input   [47:0]          tlu_idtsb_8k_ptr ;
input   [47:13]         lsu_tlu_tlb_dmp_va_m ;
input	[47:13]		ifu_tlu_pc_m ;
input	[3:0]		tlu_slxa_thrd_sel ;
input	[2:0]		tlu_tte_tag_g ;
input	[4:0]		tlu_dmp_key_vld_g ;
input			tlu_tlb_access_en_l_d1 ;
input			tlb_access_rst_l ;

input	[2:0]		tag_access_wdata_sel ;
input	[155:6]		mra_rdata ;

input			tlu_admp_key_sel ;

input 	[23:0]   	tlu_isfsr_din_g ;
input 	[23:0]   	tlu_dsfsr_din_g ;

input   [2:0]          	tlu_tte_wr_pid_g ;      input			tlu_tte_real_g ;	
input	[3:0]		tlu_ldxa_l1mx1_sel ;	input	[3:0]		tlu_ldxa_l1mx2_sel ;	input	[2:0]		tlu_ldxa_l2mx1_sel ;	input			tlu_tlb_tag_invrt_parity ;	input			tlu_tlb_data_invrt_parity ;	input                  	tlu_sun4r_tte_g ;       
input                  tlu_lng_ltncy_en_l ;

input                  tlu_tsb_rd_ps0_sel ;

input                 rclk ;
input                 arst_l ;
input                 grst_l ;
input                 si ;
input                 se ;

output                        so ;

output                  tlu_dtsb_split_w2 ;
output  [3:0]           tlu_dtsb_size_w2 ;
output  [47:13]        	tlu_dtag_access_w2 ;	output                  tlu_itsb_split_w2 ;
output  [3:0]           tlu_itsb_size_w2 ;
output	[58:0]		tlu_itlb_tte_tag_w2 ;
output	[42:0]		tlu_itlb_tte_data_w2 ;
output	[58:0]		tlu_dtlb_tte_tag_w2 ;
output	[42:0]		tlu_dtlb_tte_data_w2 ;
output  [5:0]           tlu_ctxt_cfg_w2 ;       output	[40:0]		tlu_idtlb_dmp_key_g ;


output	[3:0]		tlu_dsfsr_flt_vld ;
output	[3:0]		tlu_isfsr_flt_vld ;

output	[12:0]		tlu_tag_access_ctxt_g ;
output	[63:0]		lsu_exu_ldxa_data_g ;

output	[47:13]		tlu_tsb_base_w2_d1 ;


output	[155:0]		mra_wdata ;

wire    [47:0] 		,ldst_va_g ;
// st_rs3_data partitioned for vlint.
//wire	[63:0]		st_rs3_data_g ;
wire	[63:59]		st_rs3_data_b63t59_g ;
wire	[39:8]		st_rs3_data_b39t8_g ;
wire	[6:1]		st_rs3_data_b6t1_g ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
// st_rs3_data partitioned for vlint.
//wire	[63:0]		st_rs3_data_g ;
wire	[63:59]		st_rs3_data_b63t59_g ;
wire	[39:8]		st_rs3_data_b39t8_g ;
wire	[6:1]		st_rs3_data_b6t1_g ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[63:59]		 ;
wire	[39:8]		st_rs3_data_b39t8_g ;
wire	[6:1]		st_rs3_data_b6t1_g ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[39:8]		 ;
wire	[6:1]		st_rs3_data_b6t1_g ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[6:1]		 ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[63:0]		 ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire   	[47:13]        	 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0]		 ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0]		,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0]		,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		 ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[23:0]		 ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[40:0]		 ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0] 		 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[41:0]		 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;	
wire			, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg,  ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[40:0]		 ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ; 
wire	[47:0]		 ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[12:0]		,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg, ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire 	[58:55] 	 ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire 	[53:0] 		 ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire 	[58:55] 	 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire 	[53:0] 		 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire 	[41:0] 		 ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire    [47:13]          ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0]	 ;
wire	[47:0]	ldxa_l1mx1_dout_m ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;
wire	[47:0]	 ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;

    
    wire       ;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg;
    assign      = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg = ;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg;
 
    wire       ;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg;
    
    dffrl_async (.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg(.din (),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg),
                      .q   (),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg),
                      .clk (), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg), .se(), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg), .si(), .so(),
                      .rst_l ());


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg));



wire [47:13]  ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg ;	
dff_s  #(35)  (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg (
        .din    ([47:13]),
        .q      ([47:13]),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg),
        .se     (1bb),       .si (),          .so ()
        );


dff_s  #(48)  (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg (
        .din    ([47:0]),
        .q      ([47:0]),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg),
        .se     (1bb),       .si (),          .so ()
        );

dff_s  #(48)  (
        .din    (ldst_va_m[47:0]),
        .q      (ldst_va_g[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(35) dstg_g (
        .din    (lsu_tlu_tlb_dmp_va_m[47:13]),
        .q      (tlb_dmp_va_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire [4:0] tlu_dmp_key_vld_d1 ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
        .din    ([47:0]),
        .q      ([47:0]),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(35) dstg_g (
        .din    (lsu_tlu_tlb_dmp_va_m[47:13]),
        .q      (tlb_dmp_va_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire [4:0] tlu_dmp_key_vld_d1 ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .se     (1bb),       .si (),          .so ()
        );

dff_s  #(35)  (
        .din    (lsu_tlu_tlb_dmp_va_m[47:13]),
        .q      (tlb_dmp_va_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire [4:0] tlu_dmp_key_vld_d1 ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
        .din    ([47:13]),
        .q      ([47:13]),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire [4:0] tlu_dmp_key_vld_d1 ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .se     (1bb),       .si (),          .so ()
        );


wire [4:0]  ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
wire [47:13]  ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
dff_s  #(40)  (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
        .din    ({[47:13],[4:0]}),
        .q      ({[47:13],[4:0]}),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .se     (1bb),       .si (),          .so ()
        );

wire	[2:0]	,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1, ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
wire		,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1, ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
wire	[47:13]  ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
wire	[5:0]	 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
dp_mux2es #(41)	 (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
     		.in0	({[47:13],[4:0],}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1}),
    		.in1	({[47:13],1bb,[2:0],,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1,}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1}),
    				.sel	(),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
	      	.dout	({[47:13],[5:0]})
	);

assign  [40:0] =
        {
        [47:28],                [5],               [27:22],                [4],               [21:16],                [3],               [15:13],                [2],               [1],               [0]                } ;


wire     ;
`ifdef FPGA_SYN_CLK_EN
`else
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
 
 
clken_buf  (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
                .rclk   (),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
                .enb_l  (),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
                .tmb_l  (~),
                .clk    (tlb_access2_clk)
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
                .clk    ()
                ) ;
`endif
`endif

// Advance by a cycle. Do not have to reset state.
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
`ifdef FPGA_SYN_CLK_DFF
dffrle_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .en (~(tlu_tlb_access_en_l_d1)), .clk(clk),
        .se     (1'b0),       .si (),          .so ()
        );
`else
dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1)
                ) ;



 
 
dffrl_s  #(41)  (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
        .din    ([40:0]),
        .q      ([40:0]),
        .rst_l  (),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .clk    (),
        .se     (1'b0),       .si (),          .so ()
        );
`endif
`endif

assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .se     (1bb),       .si (),          .so ()
        );



assign  [40:0] = [40:0] ;




mux3ds #(13)	(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1(
    		.in0	([12:0]),     		.in1	(13d0),		      		.in2	([12:0]), 		.sel0	([0]),
		.sel1	([1]),
		.sel2	([2]),
	      	.dout	([12:0])
	);



dff_s  #(13)  (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 (
        .din    ([12:0]),
        .q    	([12:0]),
        .clk 	(),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
        .se     (1bb),       .si (),          .so ()
        ); 

wire	[15:0]	 ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
assign	[15:0] = [47:32] & {16{~}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1}} ;

mux3ds #(48)	(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1(
    		.in0	({[15:0],[31:13],[12:0]}),     		.in1	({[47:13],[12:0]}),      		.in2	([47:0]),			.sel0	([0]),
		.sel1	([1]),
		.sel2	([2]),
	      	.dout	([47:0])
	);

assign        [12:0] = [12:0] ;

wire	[47:0]	 ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1 ;
dp_mux2es #(48)	(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1(
    		.in0	({[15:0],[31:0]}),     		.in1	([47:0]), 		.sel	(),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1),
	      	.dout	([47:0])
	);

assign	[155:0] = 
		{[47:12],8d0,	
		[3:0],		 [47:12],8d0, 	
	 	[3:0], 		 [47:0],			 [10:8], 		 [2:0], 		 6d0};




assign	[47:13] = 