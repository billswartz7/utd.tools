 
 

 

module cmp_sram_redhdr (
      fuse_ary_wren, fuse_ary_rid, fuse_ary_repair_value, 
   fuse_ary_repair_en, spc_efc_xfuse_data, scanout, 
      rclk, se, scanin, arst_l, testmode_l, efc_spc_fuse_clk1, 
   efc_spc_fuse_clk2, efc_spc_xfuse_data, efc_spc_xfuse_ashift, 
   efc_spc_xfuse_dshift, ary_fuse_repair_value, ary_fuse_repair_en
   );

   input		rclk;
   input		se;
   input		scanin;			   input    arst_l;
   input    testmode_l;

      input		efc_spc_fuse_clk1;
   input		efc_spc_fuse_clk2;
   input		efc_spc_xfuse_data;
   input		efc_spc_xfuse_ashift;	   input		efc_spc_xfuse_dshift;	
      input [7:0] ary_fuse_repair_value;     input [1:0] ary_fuse_repair_en;        

         output      fuse_ary_wren;            output [5:0] fuse_ary_rid;            output [7:0] fuse_ary_repair_value;   output [1:0] fuse_ary_repair_en;   
      output       spc_efc_xfuse_data;

      output       scanout;

 

      wire         ;
   wire         int_clk1;
   wire         int_clk2;
   wire         int_scanout; // !! hook up to last flop in scan chain !!
   wire         int_scanin;  // !! hook up to 1st flop in scan chain !!

   wire [6:0]   addr_shft_nxt;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         int_clk2;
   wire         int_scanout; // !! hook up to last flop in scan chain !!
   wire         int_scanin;  // !! hook up to 1st flop in scan chain !!

   wire [6:0]   addr_shft_nxt;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         int_scanout; // !! hook up to last flop in scan chain !!
   wire         int_scanin;  // !! hook up to 1st flop in scan chain !!

   wire [6:0]   addr_shft_nxt;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ; // !! hook up to last flop in scan chain !!
   wire         int_scanin;  // !! hook up to 1st flop in scan chain !!

   wire [6:0]   addr_shft_nxt;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;    wire         ;  // !! hook up to 1st flop in scan chain !!

   wire [6:0]   addr_shft_nxt;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;  
   wire [6:0]   ;
   wire [6:0]   addr_shft_ff;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire [6:0]   ;
   wire         addr_shft_en;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         wren_bit;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;

   wire [11:0]  data_shft_nxt;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

   wire [11:0]  ;
   wire [11:0]  data_shft_ff;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire [11:0]  ;
   wire         data_shft_en;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;

   wire         dshift_dly1_ff;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

   wire         ;
   wire         dshift_dly2_ff;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         ashift_dly1_ff;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         ashift_dly2_ff;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         wren_ff;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         wren_ph1;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;
   wire         rden_ph1;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   wire         ;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   // End of automatics

   //
   // Code Begins Here
   //

   assign       clk = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

   
      
         
   assign        = rclk;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = ;
   
   //  Test logic
   assign       int_clk1 = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   
      assign        = (~testmode_l) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = (~) ? rclk : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
) ?  : efc_spc_fuse_clk1;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 : ;
   assign       int_clk2 = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   assign        = (~testmode_l) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = (~) ? rclk : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
) ?  : efc_spc_fuse_clk2;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 : ;
   assign       int_scanout = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   assign        = 1'b0; 

   // Need latch to avoid hold time problems
   // connect int_scanout to last flop in scan chain
   bw_u1_scanlg_2x so_lockup(.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = 1bb; 

         bw_u1_scanlg_2x (.so (scanout), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
(.so (), 
                             .sd (int_scanout), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .sd (), 
                             .ck (clk),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .ck (),  .se(se));
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),  .se());
   // connect int_scanin to first flop in scan chain
   bw_u1_scanlg_2x si_lockup(.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
));
      bw_u1_scanlg_2x (.so (int_scanin),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
(.so (),
                             .sd (scanin), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
                             .sd (), 
                             .ck (clk), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .ck (), .se(se));

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se());

   //  Shift registers
   //  Address
   assign   addr_shft_en = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
));

         assign    = efc_spc_xfuse_ashift;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = ;
   assign   addr_shft_nxt = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   assign    = {addr_shft_ff[5:0], efc_spc_xfuse_data};

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = {[5:0], };

   dffe_s #(7) addr_shft_reg (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
};

   dffe_s #(7)  (.din  (addr_shft_nxt), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din  (), 
		                        .q    (addr_shft_ff), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
		                        .q    (), 
                            .en   (addr_shft_en), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                            .en   (), 
                            .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                            .clk  (), .se(se), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());
   
   assign   fuse_ary_rid[5:0] = addr_shft_ff[6:1];
   assign   wren_bit = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());
   
   assign   [5:0] = [6:1];
   assign    = addr_shft_ff[0];

   // Data
   assign   data_shft_en = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = [0];

      assign    = efc_spc_xfuse_dshift | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 =  | dshift_dly1_ff | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 |  | rden_ph1;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 | ;

   // mux2es
   assign   data_shft_nxt = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

      assign    = rden_ph1
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = 
            ? {{3{ary_fuse_repair_en[1]}},
               ary_fuse_repair_value[7:0], 
               ary_fuse_repair_en[0]}
            : {data_shft_ff[10:0], 
               efc_spc_xfuse_data};
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:

            ? {{3{[1]}},
               [7:0], 
               [0]}
            : {[10:0], 
               };
   
   // 10:9 is unused
   dffe_s #(12) 	 data_shft_reg (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
};
   
      dffe_s #(12) 	  (.din  (data_shft_nxt),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din  (),
			                          .q    (data_shft_ff), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
			                          .q    (), 
                                .en   (data_shft_en), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                                .en   (), 
                                .clk  (int_clk1), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                                .clk  (), .se(se), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());
   
   assign   fuse_ary_repair_value = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());
   
   assign    = data_shft_ff[8:1];
   assign   fuse_ary_repair_en    = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = [8:1];
   assign       = {(data_shft_ff[11] & wren_ff),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
    = {([11] & ),
                                     (data_shft_ff[0] & wren_ff)};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
                                     ([0] & )};

   // Control
   dff_s #(1) ashift_dly1_reg (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
)};

      dff_s #(1)  (.din (efc_spc_xfuse_ashift), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din (), 
                             .q   (ashift_dly1_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .q   (),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
				                     .clk (), .se(se), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());
   dff_s #(1) ashift_dly2_reg (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());
   dff_s #(1)  (.din (ashift_dly1_ff), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din (), 
                             .q   (ashift_dly2_ff),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .q   (),
				                     .clk (int_clk1), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
				                     .clk (), .se(se), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());

   dffrl_async #(1) dshift_dly1_reg (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());

   dffrl_async #(1)  (.din (efc_spc_xfuse_dshift), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din (), 
                             .q   (dshift_dly1_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .q   (), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .rst_l (),
				                     .clk (int_clk1), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
				                     .clk (), .se(se), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());
   dffrl_async #(1) dshift_dly2_reg (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());
   dffrl_async #(1)  (.din (dshift_dly1_ff), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din (), 
                             .q   (dshift_dly2_ff), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .q   (), 
                             .rst_l (arst_l),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                             .rst_l (),
				                     .clk (int_clk1), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
				                     .clk (), .se(se), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());
   
   assign   wren_ph1 = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());
   
   assign    = dshift_dly2_ff && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 =  && ~dshift_dly1_ff && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 && ~ && wren_bit;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 && ;
   assign   rden_ph1 = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;
   assign    = ashift_dly2_ff && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 =  && ~ashift_dly1_ff && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 && ~ && ~wren_bit;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 && ~;

   // use phase two for wren since array writes in phase one
   dffrl_async #(1) wren_reg (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

      dffrl_async #(1)  (.din  (wren_ph1), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 (.din  (), 
                      .q     (wren_ff),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), 
                      .q     (),
                      .rst_l (arst_l),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
                      .rst_l (),
				              .clk   (int_clk2), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
),
				              .clk   (), .se(se), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .se(), .si(), .so());

   // address is never shifted out
   assign   spc_efc_xfuse_data = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
), .si(), .so());

      assign    = data_shft_ff[11];
   assign   fuse_ary_wren = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 = [11];
   assign    = wren_ff & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 =  & testmode_l;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
 & ;
`endif
   
endmodule // cmp_sram_redhdr

// Local Variables:
// verilog-library-directories:("." "../../common/rtl")
// verilog-library-files:      ("../../common/rtl/swrvr_clib.v")
// verilog-auto-sense-defines-constant:t
// End:
;

   
endmodule 
