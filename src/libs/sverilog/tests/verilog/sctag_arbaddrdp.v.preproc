




                                        
 	
 	



module sctag_arbaddrdp( 
      tagdp_evict_tag_c4_buf, so, arbdp_tag_idx_px2, 
   arbdp_vuad_idx1_px2, arbdp_vuad_idx2_px2, arbdp_tagdata_px2, 
   arbdp_cam_addr_px2, arbdp_new_addr5to4_px2, 
   arbdp_addr_c1c2comp_c1, arbdp_addr_c1c3comp_c1, idx_c1c2comp_c1, 
   idx_c1c3comp_c1, idx_c1c4comp_c1, idx_c1c5comp_c1, 
   arbdp_word_addr_c1, arbdp_ioaddr_c1, arbdp_addr5to4_c1, 
   arbdp_addr3to2_c1, arbdp_diag_wr_way_c2, sctag_scdata_set_c2, 
   arbaddr_addr22_c2, arbdp_addr5to4_c2, arbdp_addr_start_c2, 
   arbaddr_idx_c3, dir_cam_addr_c3, arbdp_dir_wr_par_c3, 
   arbdp_addr11to8_c3, arbdp_addr5to4_c3, arbdp_dbg_addr_c3, 
   c1_addr_eq_wb_c4, arbdp_rdmatctl_addr_c6, arbdp_waddr_c6, 
   arbdp_word_addr_c6, arbdp_byte_addr_c6, arbdp_addr22_c7, 
   arbdp_csr_addr_c9, rdmard_addr_c12, arbdp_line_addr_c7, 
   arbdp_inst_byte_addr_c7, arbdp_oqdp_l1_index_c7, 
   arbaddrdp_addr2_c8, data_ecc_idx, tag_wrdata_px2, 
      iq_arbdp_addr_px2, snpq_arbdp_addr_px2, evicttag_addr_px2, 
   arbdata_wr_data_c2, tagdp_evict_tag_c4, csr_wr_dirpinj_en, 
   mux2_snpsel_px2, mux3_bufsel_px2, mux4_c1sel_px2, 
   inc_tag_ecc_cnt_c3_n, data_ecc_idx_reset, data_ecc_idx_en, 
   sel_vuad_bist_px2, sel_decc_or_bist_idx, sel_diag_addr_px2, 
   sel_tecc_addr_px2, sel_decc_addr_px2, sel_diag_tag_addr_px2, 
   sel_lkup_stalled_tag_px2, arbctl_imiss_hit_c10, 
   tagctl_rd64_complete_c11, arbctl_imiss_hit_c4, 
   sel_c2_stall_idx_c1, bist_data_set_c1, bist_data_enable_c1, 
   bist_vuad_idx_px1, rclk, si, se, diag_or_tecc_write_px2, 
   sel_way_px2
   );


input	[39:0]	iq_arbdp_addr_px2; input	[39:0]	snpq_arbdp_addr_px2; input	[39:0]	evicttag_addr_px2; input	[27:0]	arbdata_wr_data_c2; input	[-1:0] tagdp_evict_tag_c4 ; 
output	[-1:6] tagdp_evict_tag_c4_buf ;  
input		csr_wr_dirpinj_en ; 

input		mux2_snpsel_px2; input		mux3_bufsel_px2; input		mux4_c1sel_px2; 
input		inc_tag_ecc_cnt_c3_n; input		data_ecc_idx_reset; input		data_ecc_idx_en; 
input		sel_vuad_bist_px2; input	 	sel_decc_or_bist_idx; 
input		sel_diag_addr_px2; input		sel_tecc_addr_px2; input		sel_decc_addr_px2; input		sel_diag_tag_addr_px2; input		sel_lkup_stalled_tag_px2; 

input		arbctl_imiss_hit_c10; 		     
input		tagctl_rd64_complete_c11; input		arbctl_imiss_hit_c4; 

input		sel_c2_stall_idx_c1; input	[9:0]	bist_data_set_c1; input		bist_data_enable_c1; input	[9:0]	bist_vuad_idx_px1 ; 
input		rclk;	
input		si,se;

output		so;

output	[9:0]	arbdp_tag_idx_px2 ; output	[9:0]	arbdp_vuad_idx1_px2 ; output	[9:0]	arbdp_vuad_idx2_px2 ; 
output	[27:6]	arbdp_tagdata_px2; output	[39:0]	arbdp_cam_addr_px2 ; output	[1:0]	arbdp_new_addr5to4_px2; 					

output	arbdp_addr_c1c2comp_c1;	output	arbdp_addr_c1c3comp_c1;	
output	idx_c1c2comp_c1 ; output	idx_c1c3comp_c1 ; output	idx_c1c4comp_c1 ; output	idx_c1c5comp_c1; 
output	[1:0]	arbdp_word_addr_c1; output	[39:32]	arbdp_ioaddr_c1;                                  output	[1:0]	arbdp_addr5to4_c1; output	[1:0]	arbdp_addr3to2_c1 ; 
output	[3:0]	arbdp_diag_wr_way_c2; output	[9:0]	sctag_scdata_set_c2; output		arbaddr_addr22_c2; output	[1:0]	arbdp_addr5to4_c2 ; output	arbdp_addr_start_c2;  

output	[9:0]   arbaddr_idx_c3; output	[39:8]	dir_cam_addr_c3; output		arbdp_dir_wr_par_c3 ; output	[7:4]	arbdp_addr11to8_c3; output	[1:0]	arbdp_addr5to4_c3 ; output	[5:2]	arbdp_dbg_addr_c3 ; 

output	c1_addr_eq_wb_c4; 
output	[5:2] 	arbdp_rdmatctl_addr_c6; output	[1:0] 	arbdp_waddr_c6; output	[2:0]	arbdp_word_addr_c6 ; 
output	[1:0]	arbdp_byte_addr_c6; output		arbdp_addr22_c7 ; output	[39:4]	arbdp_csr_addr_c9; output	[39:6]  	rdmard_addr_c12; output	[5:4]	arbdp_line_addr_c7 ; output	[2:0]	arbdp_inst_byte_addr_c7 ; output	[11:6]	arbdp_oqdp_l1_index_c7; 
output		arbaddrdp_addr2_c8 ; 

output	[9:0]	data_ecc_idx; 

input	diag_or_tecc_write_px2; input	sel_way_px2; output	[27:0]	tag_wrdata_px2 ; 				 




wire	[39:0]	; // diagnostic wr data after processing.
wire	[29:0] 	err_tag_c4 ; // read tag.
wire		cbit_err;
wire	[29:0] 	tecc_corr_tag_c1; // corrected tag in  the tagecc pipeline.
wire	[27:0] 	tecc_corr_tag_c2; // corrected tag in  the tagecc pipeline.
wire		par_err_tag_c4; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire	[29:0] 	 ; // read tag.
wire		cbit_err;
wire	[29:0] 	tecc_corr_tag_c1; // corrected tag in  the tagecc pipeline.
wire	[27:0] 	tecc_corr_tag_c2; // corrected tag in  the tagecc pipeline.
wire		par_err_tag_c4; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f ; wire		;
wire	[29:0] 	tecc_corr_tag_c1; // corrected tag in  the tagecc pipeline.
wire	[27:0] 	tecc_corr_tag_c2; // corrected tag in  the tagecc pipeline.
wire		par_err_tag_c4; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[29:0] 	; // corrected tag in  the tagecc pipeline.
wire	[27:0] 	tecc_corr_tag_c2; // corrected tag in  the tagecc pipeline.
wire		par_err_tag_c4; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire	[27:0] 	; // corrected tag in  the tagecc pipeline.
wire		par_err_tag_c4; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire		; // par err.
wire	[9:0]	tag_ecc_idx;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire	[9:0]	;

wire	[39:0]	mux2_addr_px2; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;

wire	[39:0]	; // snoop/mbf and fbf address.
wire	[39:0]	mux3_addr_px2; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire	[39:0]	; // snoop/mbf/fbf and Iq address.
wire	[39:0]	mux4_addr_px2; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; wire	[39:0]	; // snoop/mbf/fbf Iq address.

wire	[9:0]	data_ecc_idx_plus1; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; 
wire	[9:0]	; 

wire	[9:0]	tag_acc_idx_px2;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f; 

wire	[9:0]	;
wire	[9:0]	mux_idx2_px2;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[9:0]	;
wire	[27:0]	tag_acc_data_px2;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[27:0]	;
wire	[27:0]	mux2_tagdata_px2;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[27:0]	;



wire	[4:0]	corr_bit;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;



wire	[4:0]	;


wire	[39:0]	arbdp_addr_c1;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;


wire	[39:0]	;
wire	[39:0]	arbdp_addr_c2;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c3;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c4;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c5;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c6;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c7;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c8;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c9;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c10;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;
wire	[39:0]	arbdp_addr_c11;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:0]	;


wire	[9:0]	data_idx_px2;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;


wire	[9:0]	;
wire	[9:0]	data_idx_c1, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[9:0]	, data_bist_idx_c2, data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f, , data_bist_idx_c1;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f, ;
wire	[9:0]	stall_idx_c1;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[9:0]	;
wire	[39:8] evict_addr_c4 ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[39:8]  ;

wire	[9:0]	vuad_acc_idx_px2;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f ;

wire	[9:0]	;
wire	[9:0]	vuad_idx2_px2;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[9:0]	;
wire	[9:0]	bist_vuad_idx;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;
wire	[9:0]	;

/////////////////////////////////////////////////////////////
// dp is 30 bits wide eventhough tag is only 28 bits wide.
// ECC Correction and Generation for writing into the tag array.
// 30 bit wide dp eventhough, the tag is only 28 bits wide.
/////////////////////////////////////////////////////////////

assign	err_tag_c4 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f;


assign	 = {2'b0,tagdp_evict_tag_c4[`TAG_WIDTH-1:0]};

zzecc_sctag_30b_cor	ecc_corr(.din({err_tag_c4[29:6]}),
				 .parity(err_tag_c4[5:1]),
				 .dout(tecc_corr_tag_c1[29:6]),
				 .corrected_bit(corr_bit[4:0]));


assign	tecc_corr_tag_c1[5] = err_tag_c4[5] ^ ( corr_bit[4:0] == 5'd16) ;
assign	tecc_corr_tag_c1[4] = err_tag_c4[4] ^ ( corr_bit[4:0] == 5'd8) ;
assign	tecc_corr_tag_c1[3] = err_tag_c4[3] ^ ( corr_bit[4:0] == 5'd4) ;
assign	tecc_corr_tag_c1[2] = err_tag_c4[2] ^ ( corr_bit[4:0] == 5'd2) ;
assign	tecc_corr_tag_c1[1] = err_tag_c4[1] ^ ( corr_bit[4:0] == 5'd1) ;

assign	cbit_err	= |(corr_bit[4:0]);

zzpar32	par_bit	(.z(par_err_tag_c4), .d({err_tag_c4[29:0],2'b0}));

assign	tecc_corr_tag_c1[0] = ( par_err_tag_c4 & ~cbit_err ) ^ err_tag_c4[0] ;

dff_s     #(28) ff_tecc_corr_tag_c2   (.din(tecc_corr_tag_c1[27:0]), .clk(rclk),
                   .q(tecc_corr_tag_c2[27:0]), .se(se), .si(), .so());


/////////////////////////////////////////////////////////////////////////
// 1st level of ARB muxes 
// 1) Mux between Fb and MB addr	(in evicttag)
// 2) Mux between Mux1 and SNp data
// 3) Mux between Mux2 and IQ data
/////////////////////////////////////////////////////////////////////////


mux2ds	#(40) mux_mux2_instr_px2(.dout (mux2_addr_px2[39:0]) ,
		.in0(snpq_arbdp_addr_px2[39:0]), .in1(evicttag_addr_px2[39:0]),
		.sel0(mux2_snpsel_px2), .sel1(~mux2_snpsel_px2)); 

mux2ds	#(40) mux_mux3_instr_px2(.dout (mux3_addr_px2[39:0]) ,
		.in0(mux2_addr_px2[39:0]), .in1(iq_arbdp_addr_px2[39:0]),
		.sel0(mux3_bufsel_px2), .sel1(~mux3_bufsel_px2)); 

mux2ds	#(40) mux_mux4_instr_px2(.dout (mux4_addr_px2[39:0]) ,
		.in0(mux3_addr_px2[39:0]), .in1(arbdp_addr_c1[39:0]),
		.sel0(~mux4_c1sel_px2), .sel1(mux4_c1sel_px2)); 


assign	arbdp_new_addr5to4_px2 = mux3_addr_px2[5:4]; // column offset 
assign	arbdp_cam_addr_px2 =  mux4_addr_px2[39:0] ; // miss buffer cam address.

////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE VUAD.
////////////////////////////////////////////////////////////////////////


// data ecc index manipulation.
assign	data_ecc_idx_plus1 = data_ecc_idx + 10'b1 ;

//dffre   #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
//                 .en(data_ecc_idx_en), .clk(rclk), .rst(data_ecc_idx_reset),
//                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_data_ecc_idx
            (.clk   (clk_data_ecc_idx),   .rclk  (rclk),
             .enb_l (~data_ecc_idx_en),   .tmb_l (~se)
            ) ;
dffr_s    #(10)  ff_data_ecc_idx  (.din(data_ecc_idx_plus1[9:0]),
                 .clk(clk_data_ecc_idx), .rst(data_ecc_idx_reset),
                 .q(data_ecc_idx[9:0]), .se(se), .si(), .so());

// THIS FLOP IS NEW 
dff_s    #(10)  ff_bist_vuad_idx_px2  (.din(bist_vuad_idx_px1[9:0]),
                 	.clk(rclk), 
                 	.q(bist_vuad_idx[9:0]), .se(se), .si(), .so());


mux2ds	#(10) 	mux_vuad_acc_idx_px2(.dout ( vuad_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(bist_vuad_idx[9:0]), // tecc idx
			.sel0(~sel_vuad_bist_px2), //  sel decc
			.sel1(sel_vuad_bist_px2)); // sel tecc

mux2ds	#(10) mux_vuad_idx2_px2(.dout (vuad_idx2_px2[9:0] ) ,
			.in0(vuad_acc_idx_px2[9:0]), // bist or decc idx
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_decc_or_bist_idx),  // select diag/bist addr
			.sel1(~sel_decc_or_bist_idx)); // ~select diag/bist addr

assign	arbdp_vuad_idx1_px2 = mux3_addr_px2[17:8] ; // index for unstalled operations.

assign	arbdp_vuad_idx2_px2 = vuad_idx2_px2[9:0] ; // index for stalled operations.

//mux2ds #(10) mux_vuad_idx_px2(.dout (vuad_idx_px2[9:0] ) ,
			//.in0(vuad_idx2_px2[9:0]), 
			//.in1(mux3_addr_px2[17:8]), 
			//.sel0(sel_stall_vuad_idx),  
			//.sel1(~sel_stall_vuad_idx)); 

//dff    #(10) ff_vuad_idx_c1   (.din(vuad_idx_px2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c1[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c2   (.din(vuad_idx_c1[9:0]), .clk(rclk), 
		//.q(vuad_idx_c2[9:0]), .se(se), .si(), .so());
//
//dff    #(10) ff_vuad_idx_c3   (.din(vuad_idx_c2[9:0]), .clk(rclk), 
		//.q(vuad_idx_c3[9:0]), .se(se), .si(), .so());


////////////////////////////////////////////////////////////////////////
// INDEX BITS TO THE TAG.
// The index of a C1 stalled instruction is muxed with the following
// components to generate the address for accessing tag/vuad arrays
// tag_ecc addr.
// data_ecc_addr.
// tag diagnostic addr.
// ( The tag BIST mux is located inside the tag array )
//
// two separate addresses are sent to the tag array/vuad array.
// these arrays select between the new address or the address of the 
// stalled instruction. The select signal is generated in arbctl.v
////////////////////////////////////////////////////////////////////////
//dffe    #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]),
//		       .en(inc_tag_ecc_cnt_c3_n), .clk(rclk),
//                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());

clken_buf  ckbuf_idx_hold
            (.clk   (clk_idx_hold),            .rclk  (rclk),
             .enb_l (~inc_tag_ecc_cnt_c3_n),   .tmb_l (~se)
            ) ;
dff_s     #(10)    ff_idx_hold_c2   (.din(arbdp_addr_c2[17:8]), .clk(clk_idx_hold),
                       .q(tag_ecc_idx[9:0]), .se(se), .si(), .so());


mux3ds	#(10) 	mux_tag_idx_px(.dout ( tag_acc_idx_px2[9:0] ) ,
			.in0(data_ecc_idx[9:0]),  // decc idx
			.in1(tag_ecc_idx[9:0]), // tecc idx
			.in2(arbdp_addr_c2[17:8]), // diagnostic wr.
			.sel0(sel_decc_addr_px2), //  sel decc
			.sel1(sel_tecc_addr_px2), // sel tecc
			.sel2(sel_diag_addr_px2)); // sel diag wr.

mux2ds	#(10) mux_mux_idx2_px2(.dout (mux_idx2_px2[9:0] ) ,
			.in0(tag_acc_idx_px2[9:0]), // tecc, decc and diag write.
			.in1(arbdp_addr_c1[17:8]), // stalled addr
			.sel0(sel_diag_tag_addr_px2),  // select diag/tecc/decc addr
			.sel1(~sel_diag_tag_addr_px2)); // sel stalled addr.

mux2ds	#(10) mux_data_idx_px2(.dout (data_idx_px2[9:0] ) ,
			.in0(mux_idx2_px2[9:0]), // C1 or modified index
			.in1(mux3_addr_px2[17:8]), // instruction Px2 addr
			.sel0(sel_lkup_stalled_tag_px2),  // select diag/tecc/decc addr
			.sel1(~sel_lkup_stalled_tag_px2)); // sel stalled addr.

assign	arbdp_tag_idx_px2 =  data_idx_px2[9:0]; // index f = {2bb,