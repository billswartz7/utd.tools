#!/bin/sh
# This comment makes this script an executable. Do *NOT* delete \
eval exec ${ICDIR}/bin/icos itranslate -v -do $0 ${1+"$@"}

set routine assemble
set previous droute

global env
global argv
global icdirG
if {[info exists env(ICDIR)]} {
  set icdirG $env(ICDIR)
} {
  puts stderr "ERROR:cannot get iTools environment variable:ICDIR"
  exit 1
}
lappend auto_path $icdirG/tcl/common

set args $argv
set num_args [llength $args]
for {set i 0} {$i < $num_args} {incr i} {
  set arg_el [lindex $args $i]
  twmessage imsg null "argv\[$i]: $arg_el\n"
}
incr i -1
set dsn [lindex $args $i]

twbackup_directory assemble
cd assemble

# Now source any necessary do files.
::utdtools::source_flow_do_files $dsn a

set num_parts $::utdtools::numPartitionS
set dsn $::utdtools::designNameS
twmessage imsg null "Welcome to the Sim Assembly Program...\n"
twmessage imsg null "We are going to process $num_parts...\n"

# Now do some functionality
# We should be in the floorplan directory as we created a directory here.
# eval exec ${OPENROAD}/bin/Darwin/flow -s p -dir cut .... 
set dirname [pwd]
set folder [file tail $dirname]
if {$folder != "assemble"} {
  twmessage errmg $routine "we are not in the proper directory:$folder\n"
  twwait
  exit 1
}

# ######################## LEF ############################
set input_name $::utdtools::lef_fileS
if {$input_name != ""} {
  # change this to multiple files if needed
  set fpath [::utdtools::search_input $input_name [list . ../${previous}/output ../ ../../] true]
  if {$fpath == ""} {
    twmessage errmsg $routine "No input file named $input_name found. Aborting\n"
    twwait
    exit 1
  }
}
twmessage imsg $routine "reading LEF file:$fpath\n"
twcheck_ports off
twread_lef $fpath -scale -model_obs keepout

# We need to do this for TimberWolf
if {([info exists ::utdtools::feednameS]) && ($::utdtools::feednameS != "")} {
  twmake_default_feedthru -exists $::utdtools::feednameS
}

# ######################## TIMING ############################
set input_name $::utdtools::timing_fileS
if {$input_name != ""} {
  # change this to multiple files if needed
  set fpath [::utdtools::search_input $input_name [list . ../${previous}/output ../ ../../] true]
  if {$fpath == ""} {
    twmessage errmsg $routine "No input file named $input_name found. Aborting\n"
    twwait
    exit 1
  }
}
twmessage imsg $routine "reading Synopsys Library file:$fpath\n"
twread_synopsys -new $fpath

# ######################## DEF ############################
if {$num_parts == 1} {  
  set input_name $::utdtools::def_fileS
  if {$input_name != ""} {
    # change this to multiple files if needed
    set def_path [::utdtools::search_input $input_name [list . ../${previous}/output ../ ../../] true]
    if {$def_path == ""} {
      twmessage errmsg $routine "No input file named $input_name found. Aborting\n"
      twwait
      exit 1
    }
  }
  twmessage imsg $routine "reading DEF file:$def_path\n"
  twread_def $def_path -convert_to_exact_pads
} else {
  twmessage errmsg $routine "multiple partitions not supported yet.\n"
  exit 1
}

# Now output the TimberWolf files
twbackup_directory output



###################################################################
# For now just copy def file to the output directory
###################################################################
set outfile [file join [pwd] output ${dsn}.def]
if {[file type $def_path] == "link"} {
  if {[catch {set real_file_path [file readlink $def_path]} msg]} {
    twwait
  }
  set full_path [file join ../ droute output $real_file_path]
} else {
  set full_path $def_path
}
file copy $full_path $outfile
exit 0
