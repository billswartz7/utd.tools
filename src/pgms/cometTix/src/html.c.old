#include <cometconfig.h>
#include <utd/base.h>
#include <utd/string.h>
#include <utd/msg.h>
#include <tcl/tcl.h>

int EZeval_html(Tcl_Interp *interp) 
{
 int size = 462;
 int i,err,length;
 char *script ;
 const char *trace;
 char *cmds[] = {
   "",
   "namespace eval twez {",
   "  variable html_winS",
   "  variable loc_stackS",
   "  variable cond_stack_dataS",
   "",
   "  proc link_callback {win href} {",
   "      upvar #0 HM$win var",
   "      variable configS",
   "      variable eventS",
   "",
   "      if {[info exists configS(rendering_locked)]} {",
   "	utdalert_user errmsg link_callback \\",
   "	\"HTML link traversal is not possible when a program is running.  Either kill the \\",
   "  program with pid:$configS(rendering_locked) or wait for it to finish. If the \\",
   "  program was started inside an EZ window, make sure to hit the Exit button.\"",
   "	return ;",
   "      }",
   "",
   "      set win_new $var(S_restore_win)",
   "      if {$win_new != $win} {",
   "	regsub -all {%} $href {%%} href2",
   "	foreach i [array names eventS] {",
   "	  $win tag bind  L:$href <$i> {}",
   "	}",
   "	update",
   "	set win $win_new",
   "      }",
   "      ",
   "      if {[string match #* $href]} {",
   "	      HTML_save_place",
   "	      HTML_render $href $win",
   "	      return",
   "      }",
   "      if {[string match /* $href]} {",
   "	      set url $href",
   "      } else {",
   "	      upvar #0 HM$win var",
   "	      set wdir $var(S_cwd)		;# home wd",
   "	      set url $wdir/$href",
   "      }",
   "      update",
   "      HTML_save_place",
   "      HTML_render $url $win",
   "  }",
   "",
   "  proc stacktrace {} {",
   "    set lvl [info level -1]",
   "    return \"Stack trace:\\n\\t$lvl\\n\"",
   "  }",
   "",
   "",
   "  proc set_image {win handle src} {",
   "	  variable urlS",
   "	  if {[string match /* $src]} {",
   "		  set image $src",
   "	  } else {",
   "		  set image [file dirname $urlS]/$src",
   "	  }",
   "	  ez_message msg \"Fetching image $image\"",
   "	  update",
   "	  if {[string first \" $image \" \" [image names] \"] >= 0} {",
   "		  got_image $handle $image",
   "	  } else {",
   "		  set type photo",
   "		  if {[file extension $image] == \".bmp\"} {set type bitmap}",
   "		  if {[catch {image create $type $image -file $image} msg]} {",
   "		    utdmsg errmsg set_image \"problem:$msg\\n\";return;",
   "		  }",
   "		  got_image $handle $image",
   "	  }",
   "  }",
   "",
   "",
   "  proc calc_text_width {win} {",
   "      set width 0",
   "      scan [$win index end-1chars] %d num_lines",
   "      for {set line 1} {$line <= $num_lines} {incr line} {",
   "	set line_w [lindex [$win dlineinfo $line.0] 2]",
   "	if {$line_w !=\"\"} {",
   "	  if {[expr {$line_w > $width}]} {",
   "	    set width $line_w",
   "	  }",
   "	}",
   "      }",
   "      return [expr {$width + 10}]",
   "  }",
   "",
   "  proc calc_text_height {win} {",
   "      scan [$win index end-1chars] %d num_lines",
   "      for {set line $num_lines} {$line >= 1.0} {incr line -1} {",
   "	set line_info [$win dlineinfo ${num_lines}.0]",
   "	if {$line_info != \"\"} {",
   "	  set h_offset [lindex $line_info 1]",
   "	  set h_base [lindex $line_info 4]",
   "	  return [expr {$h_offset + $h_base}]",
   "	}",
   "      }",
   "      return 10",
   "  }",
   "",
   "  proc ezeval_tk {win param} {",
   "	  upvar #0 HM$win var",
   "",
   "",
   "	  array set align_map \\",
   "	    {top top    middle center   center center  bottom bottom}",
   "	  set align bottom",
   "	  extract_param $param align",
   "	  catch {set align $align_map([string tolower $align])}",
   "",
   "	  set alt \"<image>\"",
   "	  extract_param $param alt",
   "",
   "	  set num [extract_param $param procedure]",
   "	  if {$num < 1} {",
   "	     return ;",
   "	  }",
   "",
   "	  set argc [extract_param $param args]",
   "",
   "	  set border 0",
   "	  extract_param $param border",
   "",
   "	  set padx 20",
   "	  set pady  2",
   "	  extract_param $param padx",
   "	  extract_param $param pady",
   "",
   "	  set item $win.$var(tags)",
   "	  set label $item",
   "	  if {[extract_param $param width] && [extract_param $param height]} {",
   "	      frame $item -width $width -height $height -bd $border",
   "	      pack propagate $item 0",
   "	  } else {",
   "	      frame $item -bd $border",
   "	  }",
   "	  bind $item <Button-1> {",
   "	    ::twez::win_resize_start %W %X %Y \\",
   "	  }",
   "	  bind $item <ButtonRelease-1> {",
   "	    ::twez::win_resize_end %W %X %Y \\",
   "	  }",
   "	  bind $item <B1-Motion> {",
   "	    ::twez::win_resize_motion %W %X %Y \\",
   "	  }",
   "",
   "	  if {$argc > 0} {",
   "	    if {[catch {$procedure $label $args} result_msg]} {",
   "	      puts stderr \"Problem\\[eval_tk\\]:$result_msg\\nParams:$param\\n[stacktrace]\\n\"",
   "	    }",
   "	  } else {",
   "	    if {[catch {$procedure $label} result_msg]} {",
   "	      puts stderr \"Problem\\[eval_tk\\]:$result_msg\\nwin:$win\\n[stacktrace]\\n\"",
   "	    }",
   "	  }",
   "",
   "	  $win window create $var(S_insert) -align $align -window $item \\",
   "	    -padx $padx -pady $pady ",
   "",
   "	  set tags [current_tags $win]",
   "	  foreach tag $tags {",
   "	      $win tag add $tag $item",
   "	  }",
   "	  return $label	;# used by the forms package for input_image types",
   "  }",
   "",
   "",
   "",
   "",
   "  proc HTML_render {file w} {",
   "	  variable urlS",
   "	  variable stopS",
   "	  variable loadedS",
   "	  variable html_winS",
   "	  upvar #0 HM$w var",
   "",
   "	  set html_winS $w",
   "",
   "	  set fragment \"\"",
   "	  regexp {([^#]*)#(.+)} $file dummy file fragment",
   "	  if {$fragment != \"\" && $loadedS} {",
   "	    if {$file == $urlS || $file == \"\"} {",
   "	      goto $w $fragment",
   "	      return",
   "	    }",
   "	  }",
   "	  set_state $w -file $file",
   "	  set urlS $file",
   "",
   "	  ez_busy",
   "	  reset_win $w",
   "	  ez_message msg \"Displaying $file\"",
   "	  file_stop $w $file 1",
   "	  update",
   "	  twparse_html $file $w ::twez::render",
   "	  file_stop $w $file 0",
   "	  set_state $w -stop 1",
   "",
   "	  auto_save",
   "",
   "	  set reset_state [file_release $w]",
   "	  if {$reset_state} { ",
   "	    set_state $w -stop 0",
   "	    if {[info exists var(goto_enabled)]} {",
   "	      unset var(goto_enabled)",
   "	    } else {",
   "	      update",
   "	      if {$fragment != \"\"} {",
   "		goto $w $fragment",
   "	      } else {",
   "		$w see 1.0",
   "	      }",
   "	    }",
   "	    set stopS 0",
   "	    ez_ready",
   "	  }",
   "",
   "  }",
   "",
   "",
   "  proc HTML_read {file win} {",
   "	  upvar #0 HM$win var",
   "	  set Home $var(S_home)		;# home document",
   "	  if {[catch {set fd [open $file]} msg]} {",
   "		  return \"",
   "			  <title>Bad file $file</title>",
   "			  <h1>Error reading $file</h1><p>",
   "			  $msg<hr>",
   "			  <a href=$Home>Go home</a>",
   "		  \"",
   "	  }",
   "	  set result [read $fd]",
   "	  close $fd",
   "	  return $result",
   "  }",
   "",
   "  proc HTML_view {notebook page win file {size 10} {indent 1.2} {back_callback ez:save_state} } {",
   "	  HTML_save_place",
   "",
   "	  file_init $win",
   "	  init_win $win",
   "	  cond_stack init {}",
   "	  set_state $win -notebook $notebook",
   "	  set_state $win -page $page",
   "	  set_state $win -home $file",
   "	  set_state $win -cwd [file dirname $file]",
   "	  set_state $win -size $size",
   "	  set_state $win -back_callback $back_callback",
   "	  set_state $win -restore_win $win",
   "	  set_state $win -file $file",
   "	  set_indent $win $indent",
   "	  HTML_render $file $win",
   "  }",
   "",
   "  proc HTML_stack_init {} {",
   "	variable urlS",
   "	variable html_winS",
   "	variable loc_stackS",
   "",
   "	set loc_stackS(index)	0",
   "	set loc_stackS(control)	1",
   "	set loc_stackS(max)	0",
   "	set loc_stackS(valid)	1",
   "	set loc_stackS(valid2)	1",
   "	set urlS {}",
   "	set html_winS {}",
   "  }",
   "",
   "  proc cond_stack {operation data} {",
   "	variable cond_stack_dataS",
   "",
   "	if {$operation == \"init\"} {",
   "	  set cond_stack_dataS {}",
   "	} elseif {$operation == \"push\"} {",
   "	  lappend cond_stack_dataS $data",
   "	} elseif {$operation == \"pop\"} {",
   "	  set result [lindex $cond_stack_dataS end]",
   "	  set cond_stack_dataS [lreplace $cond_stack_dataS end end]",
   "	  return $result",
   "	} elseif {$operation == \"peek\"} {",
   "	  set result [lindex $cond_stack_dataS end]",
   "	  return $result",
   "	} else {",
   "	  puts stderr \"cond_stack:unknown operation:$operation\"",
   "	}",
   "  }",
   "",
   "  proc HTML_print_stack {msg} {",
   "	variable loc_stackS",
   "	set max $loc_stackS(max)",
   "	puts stderr \"$msg\"",
   "	puts stderr \"index:$loc_stackS(index) max:$max\"",
   "	for {set i 1} {$i <= $max} {incr i} {",
   "	  puts stderr \"loc_stackS\\[$i\\]:$loc_stackS($i)\"",
   "	}",
   "  }",
   "",
   "  proc HTML_push {args} {",
   "	variable loc_stackS",
   "",
   "	set index $loc_stackS(index)",
   "	set new_list {}",
   "	foreach i $args {",
   "	  lappend new_list $i",
   "	}",
   "	if {$index > 0} {",
   "	  set cur_path $loc_stackS($index)",
   "	  if {$new_list == $cur_path} {",
   "	    return ;",
   "	  }",
   "	}",
   "	incr index",
   "	set loc_stackS($index) $new_list",
   "	set loc_stackS(index) $index",
   "	set loc_stackS(max) $index",
   "  }",
   "",
   "  proc HTML_pop {} {",
   "	variable loc_stackS",
   "",
   "	set index $loc_stackS(index)",
   "	set max $loc_stackS(max)",
   "",
   "	if {$max > 0} {",
   "	  set ret_path $loc_stackS($index)",
   "	  if {$index > 1} {",
   "	    incr index -1",
   "	    set loc_stackS(index) $index",
   "	  }",
   "	} else {",
   "	  set ret_path {}",
   "	}",
   "",
   "	return $ret_path",
   "  }",
   "",
   "  proc HTML_next {} {",
   "	variable loc_stackS",
   "",
   "	set index $loc_stackS(index)",
   "	set max $loc_stackS(max)",
   "",
   "	if {($max > 0) && ($index < $max)} {",
   "	  incr index",
   "	  set ret_path $loc_stackS($index)",
   "	  set loc_stackS(index) $index",
   "	} else {",
   "	  set ret_path {}",
   "	}",
   "",
   "	return $ret_path",
   "  }",
   "",
   "  proc HTML_save_enable { flag } {",
   "	variable loc_stackS",
   "",
   "	set loc_stackS(control) $flag",
   "  }",
   "",
   "  proc HTML_save_place {} {",
   "	variable urlS",
   "	variable html_winS",
   "	variable loc_stackS",
   "",
   "	if {$html_winS != \"\"} {",
   "	  upvar #0 HM$html_winS var",
   "	  if {!([info exists var(S_back_proc)])} {",
   "	    return ;",
   "	  }",
   "	  if {$var(S_back_proc) != \"\"} {",
   "	    if {$loc_stackS(control) == 1} {",
   "	      $var(S_back_proc) $html_winS $urlS",
   "	    }",
   "	  } else {",
   "	    puts stderr \"No back proc specified.\"",
   "	  }",
   "	}",
   "  }",
   "",
   "  proc win_resize_start {win x y} {",
   "    upvar #0 HM$win var",
   "",
   "    set var(startx) $x",
   "    set var(starty) $y",
   "    set widget_x [winfo rootx $win]",
   "    set widget_y [winfo rooty $win]",
   "    set widget_wid [winfo width $win]",
   "    set widget_hei [winfo height $win]",
   "    toplevel .ez_tmp -background red",
   "    wm overrideredirect .ez_tmp 1",
   "    wm geometry .ez_tmp \"=${widget_wid}x${widget_hei}+${widget_x}+${widget_y}\"",
   "  }",
   "",
   "  proc win_resize_motion {win x y} {",
   "    upvar #0 HM$win var",
   "",
   "    set halfw [expr {[winfo width  $win] / 2}]",
   "    set halfh [expr {[winfo height $win] / 2}]",
   "    set centerx [expr {[winfo rootx $win] + $halfw}]",
   "    set centery [expr {[winfo rooty $win] + $halfh}]",
   "",
   "    if {$var(startx) <= $centerx} {",
   "      set xpandx [expr {$var(startx) - $x}]",
   "    } else {",
   "      set xpandx [expr {$x - $var(startx)}]",
   "    }",
   "",
   "    if {$var(starty) <= $centery} {",
   "      set xpandy [expr {$var(starty) - $y}]",
   "    } else {",
   "      set xpandy [expr {$y - $var(starty)}]",
   "    }",
   "    set width [expr {[winfo width $win] + $xpandx}]",
   "    set height [expr {[winfo height $win] + $xpandy}]",
   "    wm geometry .ez_tmp \"=${width}x${height}\"",
   "  }",
   "",
   "  proc win_resize_end {win x y} {",
   "    upvar #0 HM$win var",
   "",
   "    set halfw [expr {[winfo width  $win] / 2}]",
   "    set halfh [expr {[winfo height $win] / 2}]",
   "    set centerx [expr {[winfo rootx $win] + $halfw}]",
   "    set centery [expr {[winfo rooty $win] + $halfh}]",
   "",
   "    if {$var(startx) <= $centerx} {",
   "      set xpandx [expr {$var(startx) - $x}]",
   "    } else {",
   "      set xpandx [expr {$x - $var(startx)}]",
   "    }",
   "",
   "    if {$var(starty) <= $centery} {",
   "      set xpandy [expr {$var(starty) - $y}]",
   "    } else {",
   "      set xpandy [expr {$y - $var(starty)}]",
   "    }",
   "    set width [expr {[winfo width $win] + $xpandx}]",
   "    set height [expr {[winfo height $win] + $xpandy}]",
   "    pack propagate $win 0",
   "    $win configure -width $width -height $height",
   "    destroy .ez_tmp",
   "    update",
   "  }",
   "",
   "",
   "",
   "  proc ezeval_expr {expression} {",
   "      variable configS",
   "",
   "      ",
   "      if {[catch {expr $expression} expr_val]} {",
   "	puts stderr \"ERROR\\[ezeval_expr\\]:$expr_val\\n[stacktrace]\\nexpression:$expression\"",
   "      } else {",
   "      }",
   "",
   "      if {$expr_val} {",
   "	return true ;",
   "      }",
   "      return false ;",
   "  }",
   "}",
  NULL };

 /* Find out how long the script is */
 length = 0;
 for (i=0;i<size;i++) length += strlen(cmds[i]);
 /* Catenate the script */
 script = UTDCALLOC(length+size+1,char);
 script[0] = '\0';
 for (i=0;i<size;i++) 
 {
  strcat(script,cmds[i]);
  strcat(script,"\n");
 }
 /* Execute the script */
 err = Tcl_Eval(interp,script);
 UTDFREE(script);
 if (err != TCL_OK)
 {
  utDmsgf(ERRMSG,MSG_AT,"EZengine", "html.tcl : %s\n",Tcl_GetStringResult(interp)) ;
  trace = Tcl_GetVar(interp,"errorInfo",TCL_GLOBAL_ONLY);
  if (trace ){
   utDmsgf(ERRMSG, MSG_AT, "EZengine","*** TCL TRACE ***\n");
   utDmsgf(ERRMSG, MSG_AT, NULL, "%s\n",trace);
   return TCL_ERROR;
  }
 }
 return TCL_OK;
}

